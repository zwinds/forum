// 对象的 key 为集合名称
// key.data 是集合的记录数据，数组内一项为一条数据
// 以部分数据、部分字段为例
{
    "article": { // 文章表
        "data": [{
                "id": "302042",
                "title": "SSR基本介绍以及API的使用",
                "browse_count": 173,
                "collection_count": 5,
                "comments_count": 0,
                "author": {
                    "id": "8010388",
                    "author_name": "WEB韩刚",
                    "avatar": "//img1.sycdn.imooc.com/5dafce1a00013fd501400140-160-160.jpg",
                    "status": "normal"
                },
                "classify": "后端开发",
                "thumbs_up_count": 5,
                "create_time": "2020.03.16 17:50",
                "content": "## SSR基本介绍以及API的使用\n\n\n\n### 什么是SSR？\n\n> server side prender 服务端渲染\n\n参考地址：https://ssr.vuejs.org/zh/\n\n#### 服务端渲染与客户端渲染的区别？\n\n##### 服务端渲染\n\n> 页面渲染过程是在服务端完成，最终的HTML字符串，直接通过请求发送给客户端。\n\n**服务端渲染案例Demo：**\n\n- https://ssr.vuejs.org/zh/guide/\n- https://www.hyfarsight.com/forum/forumlist/all\n- https://www.ixigua.com/?wid_try=1\n\n\n\n**优点**\n\n1. 利于SEO：不同爬虫工作原理类似，只会爬取源码，不会执行网站的任何脚本（Google除外）；\n2. 首屏加载快：首页是通过node加载的HTML字符串，用户直接可以看到完整HTML，所以更快；\n\n**缺点**\n\n1. 渲染过程在后端完成，耗费后端资源，费流量。\n2. 页面重复加载次数高、开发效率低、数据传输量大、服务器压力大。\n\n\n\n##### **客户端渲染** \n\n> 客户端请求页面时，返回是空HTML，通过请求完js，css等，在客户端进行渲染（浏览器）\n\n**客户端渲染案例Demo：**\n\n- https://element.eleme.io/#/zh-CN\n- https://www.zhisland.com/index\n- https://m.maizuo.com/v5/#/films/nowPlaying\n\n\n\n**优点**\n\n​\t\t节省后端资源，局部刷新页面，多端渲染，前后端分离。\n\n**缺点**\n\n​\t\t缺点是：首屏性能差，白屏，无法（或很难）进行 SEO等。\n\n\n\n---\n\n#### Vue实现服务端渲染Demo\n\n访问地址：https://ssr.vuejs.org/zh/guide/\n\n\n\n##### Vue实现服务端渲染使用条件\n\n- 会同时打包两套入口文件，客户端+ 服务端 （同构）\n- 服务端渲染过程中，只会执行到componentDidMount之前的生命周期钩子\n- Vue实例化对象在服务端生成时为多例模式，包含路由，store，实例化对象，均为多例模式\n- 2.5版本之前只能使用nodeJS作为ssr渲染执行环境\n\n### nuxtJS使用\n\n#### 文档地址\n\nhttps://www.nuxtjs.cn/\n\n#### 安装\n\n**npx安装**\n\n1. 原始版本\n\n   ```css\n   npx create-nuxt-app <项目名>\n   ```\n\n2. 指定版本\n\n   ```css\n   npx create-nuxt-app@2.9.2 <项目名>\n   ```\n\n   \n\n**yarn安装**\t\n\n```css\nyarn create nuxt-app <项目名>\n```\n\n\n\n```css\nProject name: 项目名称，后期也可以改，无误回车即可；\n\nProgramming language: JS语言，这里我选择了JavaScript，也可以选择TS；\n\nPackage manager: 包管理器，我选择了npm；\n\nUI framework: 是否安装UI框架，本项目我们用到了element-ui，但是官方配置貌似有些问题，我们这里选择 None，后面手动配置；\n\nNuxt.js modules: 集成模块（插件），这里我们选择axios，注意使用上下箭头将光标移到axios上使用空格选择，选中后会有一个通配符（*），然后回车；\n\nLinting tools: 格式检测工具，这玩意….反正我是直接回车跳过了；\n\nTesting framework: 单元测试框架，选择None回车即可（这里none并不是不选择，而是随机选一个的意思）\n\nRendering mode: 网站模式，这里选择Universal (SSR / SSG)，使用Nuxt的意义就在于此，选Single Page App的话我还不如直接用Vue呢；\n\nDeployment target: 开发服务器，即我们热更新的启动基础，这里选择Server (Node.js hosting)即可；\n\nDevelopment tools: 开发工具适配，如果使用vscode那就勾选第一项；\n\nWhat is your GitHub username? 选填，不想填直接回车；\n\nVersion control system: 版本管理工具，根据上一项选择填写，没有直接选择None回车；\n\n\n```\n\n\n\n---\n\n\n\n\n\n#### 目录结构\n\n```java\n└─my-nuxt-demo\n  ├─.nuxt               // Nuxt自动生成，临时的用于编辑的文件，build\n  ├─assets              // 用于组织未编译的静态资源如LESS、SASS或JavaScript\n  ├─components          // 用于自己编写的Vue组件，比如日历组件、分页组件\n  ├─layouts             // 布局目录，用于组织应用的布局组件，不可更改⭐（新版本目前需要手动创建）\n  ├─middleware          // 用于存放中间件\n  ├─node_modules\n  ├─pages               // 用于组织应用的路由及视图,Nuxt.js根据该目录结构自动生成对应的路由配置，文件名不可更改⭐\n  ├─plugins             // 用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。\n  ├─static              // 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。 服务器启动的时候，该目录下的文件会映射至应用的根路径 / 下。文件夹名不可更改。⭐\n  └─store               // 用于组织应用的Vuex 状态管理。文件夹名不可更改。⭐\n  ├─.editorconfig       // 开发工具格式配置\n  ├─.eslintrc.js        // ESLint的配置文件，用于检查代码格式（脚手架项目如果没有设置，没有此目录文件夹）\n  ├─.gitignore          // 配置git忽略文件\n  ├─nuxt.config.js      // 用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。文件名不可更改。⭐\n  ├─package-lock.json   // npm自动生成，用于帮助package的统一设置的，yarn也有相同的操作\n  ├─package.json        // npm 包管理配置文件\n  ├─README.md\n```\n\n---\n\n\n\n#### 使用\n\n##### \t路由\n\n​\t\t**参考地址**：https://zh.nuxtjs.org/docs/2.x/directory-structure/pages\n\n1. ​\t**路由文件定义**\n\n   - page 文件夹下创建vue文件，为页面级别路由文件\n\n   - layouts文件夹下进行模版定义\n\n     ```html\n     <template>\n         <nuxt />\n       </view>\n     </template>\n     ```\n\n   - 自定义模版使用\n\n     > 在layouts文件夹下定义vue文件；\n     >\n     > 在page界面组件内部定义 layout属性\n\n2. 路由跳转\n\n   - <nuxt-link to=\"linkUrl\"></nuxt-link>\n\n   - 编程式跳转 this.$router.push('linkUrl')\n\n   - 404界面处理\n\n     ```js\n      router: {\n         linkExactActiveClass: 'on',\n         /* 扩展路由对象 */\n         extendRoutes(routes, resolve) {\n           routes.push({\n             name: 'custom',\n             path: '*',\n             component: resolve(__dirname, './pages/404.vue')\n           })\n         },\n         // middleware: ['redirect'],`\n       }\n     ```\n\n     \n\n3. 二级路由创建\n\n   1. page下定义同名文件夹\n\n   2. 文件夹内部定位二级路由文件，名称自行定义\n\n      ![image-20210706150327823](https://tva1.sinaimg.cn/large/008i3skNly1gs78qyaz52j30my0hcmyi.jpg)\n\n4. 路由重定向（使用middleware进行中间件跳转）\n\n   1. nuxt.config文件配置route选项\n\n      ```js\n      router: {\n          middleware: ['redirect']\n        }\n      ```\n\n   2. 创建middleware文件夹，定义redirect.js文件\n\n      ```javascript\n      \n      export default function ({ route, app, store, redirect, ctx, req, $axios, error }) {\n          if (route.path === '/test') {\n              redirect('/test/child_test')\n          }\n      }\n      ```\n\n      \n\n5. 动态路由定义\n\n   1. 在 Nuxt.js 里面定义带参数的动态路由，需要创建对应的**以下划线作为前缀**的 Vue 文件 或 目录。\n   2. 获取动态参数{{$route.params['文件名']}}\n\n\n\n---\n\n\n\n##### 三方UI库使用\n\n- 配置文件中直接使用即可；\n\n- plugin文件夹下创建三方引入文件\n\n##### 数据请求\n\n**非跨域数据请求**\n\n```javascript\n async asyncData({ store, $axios, params }) {\n    const { data: { data, code } } = await $axios.get('https://study.duyiedu.com/api/herolist')\n    if (code === 0) {\n      return { list: data }\n    }\n  }\n```\n\n**跨域数据请求**\n\n1. 下载@nuxtjs/proxy插件\n\n2. nuxt.config.js文件中配置modules选项\n\n   ```javascript\n   modules:['@nuxtjs/proxy'],\n     proxy:{\n       '/代理地址':{\n         target:'https://study.duyiedu.com/api/movies',\n         pathRewrite:{\n           '^/getMovie':''\n         }\n       }\n     }\n   ```\n\n   \n\n##### 使用store数据\n\n> ​\tstore文件夹下创建模块文件，导出文件为函数返回值为对象\n\n```js\nexport const state = () => ({\n    userInfo: null\n});\n```\n\n> ​\t组件内使用\n\n```javascript\n$store.state.user.userInfo\n```\n\n\n\n##### 路由守卫\n\n###### \t使用plugin实现路由守卫\n\n> ​\tnuxt.conig.js文件进行plugins扩展配置\n\n```js\n\t  plugins: [\n    { src: '@/plugins/check_before_each.js', ssr: false }  // ssr => 是否在服务端渲染阶段执行\n  ],\n```\n\n> plugin文件夹下定义 check_before_each.js文件 （文件名没有限制）\n\n```javascript\nexport default function (obj) {\n    obj.app.router.beforeEach((to, form, next) => {\n        if (to.name !== 'userSetting-login' && !window.localStorage.userInfo) {\n            next('/userSetting/login');\n        } else {\n            window.localStorage.userInfo && obj.store.commit('user/settingUser', JSON.parse(window.localStorage.userInfo))\n            next()\n        }\n    })\n}\n```\n\n<!--该方法产生问题：无法在服务端渲染阶段进行路由拦截-->\n\n\n\n###### 使用middlewear进行路由拦截\n\n> nuxt中定义router的middleware配置\n\n```jsx\nrouter: {\n    linkExactActiveClass: 'on',\n    extendRoutes(routes, resolve) {\n      routes.push({\n        name: 'custom',\n        path: '*',\n        component: resolve(__dirname, './pages/404.vue')\n      })\n    },\n    middleware: ['redirect'],\n  },\n```\n\n\n\n> redirect进行拦截配置\n\n```js\nexport default function ({ route, app, store, redirect, ctx, req, $axios, error }) {\n    if (!process.client) {\n        const user = req.ctx.session.userInfo\n        if (!user && !route.path.includes('userSetting/login')) {\n            redirect('/userSetting/login')\n        }\n    } else {\n    }\n}\n```\n\n\n\n\n\n\n\n\n",
                "abstractText": "SSR基本介绍以及API的使用\n什么是SSR？\n\nserver side prender 服务端渲染\n\n参考地址：https://ssr.vuejs.org/zh/\n服务端渲染与客户端渲染的区别？\n服务端渲染\n\n页面渲染过程是在服务端完成，最终的HTML字符串，直接通过请求发送给客户端。\n\n服务端渲",
                "cover": [
                    "http://upload-images.jianshu.io/upload_images/1919394-dca940ffa0bd52c7.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp",
                    "http://upload-images.jianshu.io/upload_images/1919394-db2811f17e425c2f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp",
                    "http://upload-images.jianshu.io/upload_images/1919394-e90f40b5a4b02695.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp",
                    "https://lee-blog.oss-cn-shanghai.aliyuncs.com/2020/03/16/15843496433035.jpg",
                    "https://lee-blog.oss-cn-shanghai.aliyuncs.com/2020/03/16/15843496546451.jpg",
                    "https://lee-blog.oss-cn-shanghai.aliyuncs.com/2020/03/16/15843496657408.jpg",
                    "https://lee-blog.oss-cn-shanghai.aliyuncs.com/2020/03/16/15843496759816.jpg",
                    "https://lee-blog.oss-cn-shanghai.aliyuncs.com/2020/03/16/15843496892846.jpg",
                    "https://lee-blog.oss-cn-shanghai.aliyuncs.com/2020/03/16/15843497052573.jpg",
                    "https://lee-blog.oss-cn-shanghai.aliyuncs.com/2020/03/16/15843497175683.jpg",
                    "https://lee-blog.oss-cn-shanghai.aliyuncs.com/2020/03/16/15843499344907.jpg"
                ],
                "mode": "column"
            },
            {
                "id": "301911",
                "title": "《故宫博物院》集训营直播课开讲啦（4月17号）",
                "browse_count": 293,
                "collection_count": 1,
                "comments_count": 0,
                "author": {
                    "id": "8010388",
                    "author_name": "WEB前端讲师韩刚",
                    "avatar": "https://pc.hyfarsight.com/Fsf4RfIJyetNpvsXUmlGbQkhYoWA",
                    "status": "normal"
                },
                "classify": "精彩直播",
                "thumbs_up_count": 1,
                "create_time": "2020.03.13 11:39",
                "content": "渡一四日集训营《故博宫物馆官网首页》（pc端）正开式启\n\n5月16日晚上8:00  渡一新人气讲师韩刚带大家完成首页完整项目\n\n像渐隐渐现轮播图、蒙层效果，3D展示等效果一一实现，报名截止于明天！\n\n### 课程内容\n企业实战什是么样子？谢老师将带会大家从html css开完始整实现神原游戏官网动移端页面项目！包括所有交互功能，抓紧报名哦\n\n![https://tva1.sinaimg.cn/large/008i3skNly1gshp1imuagj30r85vg7ri.jpg](https://tva1.sinaimg.cn/large/008i3skNly1gshp1imuagj30r85vg7ri.jpg)\n\n1. 项目整体布局、页面成型\n   时间：7月14日 20:00-21:30\n2. 通用布局，轮播图、前后端数据通信\n   时间：7月15日 20:00-21:30\n3. 新闻资讯，滚动栏弹框效果\n   时间：7月16日 20:00-21:30\n\n\n### 讲师简介\n> 渡一教育前端讲师，精通 js 开发，对 js 的原型机制有深入研究和应用心得。精通常见的 js 开发框架与 js 库，Vue、React ，jQuery 等。\n",
                "cover": [
                    "https://pc.hyfarsight.com/Fsf4RfIJyetNpvsXUmlGbQkhYoWA"
                ],
                "mode": "base"
            },
            {
                "id": "298045",
                "title": "websocket特点",
                "browse_count": 6460,
                "collection_count": 93,
                "comments_count": 15,
                "author": {
                    "id": "4294850",
                    "author_name": "web-alan",
                    "avatar": "//img1.sycdn.imooc.com/54584e2c00010a2c02200220-160-160.jpg",
                    "status": "normal"
                },
                "classify": "后端开发",
                "thumbs_up_count": 93,
                "create_time": "2019.12.19 12:04",
                "content": "## 特点\n（1）建立在 TCP 协议之上，服务器端的实现比较容易。\n\n（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。\n\n（3）数据格式比较轻量，性能开销小，通信高效。\n\n（4）可以发送文本，也可以发送二进制数据。\n\n（5）没有同源限制，客户端可以与任意服务器通信。\n\n（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。\n## 客户端的 API\n### WebSocket 构造函数\n> 完整参数\n[https://developer.mozilla.org/en-US/docs/Web/API/WebSocket#Constructor](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket#Constructor) \n\n```js\nvar ws = new WebSocket('ws://localhost:8080');\n```\n ### webSocket.readyState \n> readyState属性返回实例对象的当前状态，共有四种。\n\n- CONNECTING：值为0，表示正在连接。\n- OPEN：值为1，表示连接成功，可以通信了。\n- CLOSING：值为2，表示连接正在关闭。\n- CLOSED：值为3，表示连接已经关闭，或者打开连接失败。\n\n### webSocket.onopen\n> 实例对象的onopen属性，用于指定连接成功后的回调函数。\n\n```js\nws.onopen = function () {\n  ws.send('Hello Server!');\n}\n```\n如果要指定多个回调函数，可以使用addEventListener方法。\n```js\nws.addEventListener('open', function (event) {\n  ws.send('Hello Server!');\n});\n```\n\n### webSocket.onclose\n> 实例对象的onclose属性，用于指定连接关闭后的回调函数。\n\n```js\nws.onclose = function(event) {\n  var code = event.code;\n  var reason = event.reason;\n  var wasClean = event.wasClean;\n  // handle close event\n};\n\nws.addEventListener(\"close\", function(event) {\n  var code = event.code;\n  var reason = event.reason;\n  var wasClean = event.wasClean;\n  // handle close event\n});\n```\n\n### webSocket.onmessage\n>实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。\n```js\nws.onmessage = function(event) {\n  var data = event.data;\n  // 处理数据\n};\n\nws.addEventListener(\"message\", function(event) {\n  var data = event.data;\n  // 处理数据\n});\n```\n==注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。==\n```js\nws.onmessage = function(event){\n  if(typeof event.data === String) {\n    console.log(\"Received data string\");\n  }\n\n  if(event.data instanceof ArrayBuffer){\n    var buffer = event.data;\n    console.log(\"Received arraybuffer\");\n  }\n}\n```\n\n###  webSocket.send()\n> 实例对象的send()方法用于向服务器发送数据。\n```js\nws.send('your message');\n```\n发送 Blob 对象的例子。\n```js\nvar file = document\n  .querySelector('input[type=\"file\"]')\n  .files[0];\nws.send(file);\n```\n> 发送 ArrayBuffer 对象的例子。\n```js\n\n// Sending canvas ImageData as ArrayBuffer\nvar img = canvas_context.getImageData(0, 0, 400, 320);\nvar binary = new Uint8Array(img.data.length);\nfor (var i = 0; i < img.data.length; i++) {\n  binary[i] = img.data[i];\n}\nws.send(binary.buffer);\n```\n### webSocket.onerror\n\n> 实例对象的onerror属性，用于指定报错时的回调函数。\n```js\nsocket.onerror = function(event) {\n  // handle error event\n};\n\nsocket.addEventListener(\"error\", function(event) {\n  // handle error event\n});\n```\n\n## 服务端实现\n> [socket.io](https://socket.io/)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "cover": [
                    "http://img2.sycdn.imooc.com/5dfae4a50001a51905000256.jpg",
                    "//img1.sycdn.imooc.com/5dfaf472000141b612800910.jpg",
                    "//img1.sycdn.imooc.com/5dfb073a0001b38512800896.jpg",
                    "//img1.sycdn.imooc.com/5dfb074d00016a8412800899.jpg",
                    "http://img2.sycdn.imooc.com/5dfae6020001223205000515.jpg",
                    "//img1.sycdn.imooc.com/5dfb08530001ffa125898333.png",
                    "//img1.sycdn.imooc.com/5dfb08730001804327632092.png"
                ],
                "mode": "column"
            },
            {
                "id": "286282",
                "title": "我是个前端开发者，我到底要不要学Node开发？",
                "browse_count": 10938,
                "collection_count": 71,
                "comments_count": 24,
                "author": {
                    "id": "4294850",
                    "author_name": "7七月",
                    "avatar": "//img1.sycdn.imooc.com/54584e2c00010a2c02200220-160-160.jpg",
                    "status": "normal"
                },
                "classify": "前端开发",
                "thumbs_up_count": 71,
                "create_time": "2019.05.06 11:45",
                "content": "\n\t\t\t\t\t\t<p style=\"text-align:center\"><img class=\"lazyload\" src=\"https://img1.sycdn.imooc.com/5ccfac620001f8d405000344.jpg\" data-original=\"https://img1.sycdn.imooc.com/5ccfac620001f8d405000344.jpg\" alt=\"https://img1.sycdn.imooc.com/5ccfac620001f8d412800880.jpg\" style=\"width:100%;\"></p><p>                                                                 春和景明</p><p><br></p><p>我总是不太善于做营销这一块，骨子里有点旧时穷酸知识分子的调调，内心里认定好的东西不需要做过多的修饰，说太多大话我会不好意思。<br></p><p>但我一个朋友言之凿凿的说，这个时代就是个浮躁的年代，你要善于制造焦虑，夸大效果，什么都得学，不学就落后，落后就要挨打。</p><p>反正课又不是药，吃不死人。<br></p><p>按照这个说法，长此以往，人人都得是苏东坡，音乐家、书法家、画家、文学家，噢，他还是个美食家。放在计算机领域，恨不得要求你，上能搞人工智能，下能搞操作系统。<br></p><p>然而世上只有一个苏东坡。人还是得认清自己，事事跟风，样样都学，反而落下个附庸风雅的名号。<br></p><p>所以，认清自己的现状，理智选择知识来学习，这一点尤为重要。没有那么多不学不行的知识，也别指望学个什么课就能脱胎换骨，达到Px，Tx。琴棋书画3年起步，5年入门，10年小成，20年大成，凭什么编程就能速成呢？<br></p><p>这世道，缺的就是清醒。<br></p><p>现在的营销都讲究“以德服人”，然而我觉得，知识这种事儿不能迷信权威，必须以理服人。讲道理，是本篇广告的“独特气质”。<br></p><p>新课是关于<a href=\"https://coding.imooc.com/class/342.html?mc_marking=3bdbadf15a609d995ceabd59428f0f79&mc_channel=shouji\" target=\"_self\">Node.js Koa</a>的课程。那么问题来了，借用姜文的话就是：你XX的给我说说，我XX的到底要不要学XX的Node.js？老子学不动了。<br></p><p>没办法，这行就这样。你不学Vue，总不是跑去学React/小程序/算法与数据结构/TS去了，不断学习根本避免不了。一入编程深似海，从此女神是路人。所以关键在于把时间投在学什么上比较划算，利益可以最大化。从经济学的角度考虑问题，兼顾短期、中期与长期的利益，才是上上佳策。<br></p><p><strong>明确表达我的观点，前端学习</strong><a href=\"https://coding.imooc.com/class/342.html?mc_marking=3bdbadf15a609d995ceabd59428f0f79&mc_channel=shouji\" target=\"_self\"><strong>node.js</strong></a><strong>，短期小收益，中期高收益，长期必然趋势。</strong><br></p><p>诚实的讲，一个前端学习服务端编程，短期收益不大。但是考虑到中长期，投入一门课时间，收益还是很可观的——关键是它保留了你未来进阶/转型的可能性，而这仅仅只需要耗费你18个小时左右的时间。<br></p><p>短期来看，对于绝大多数前端开发者，将服务端技术直接应用到工作中的可能性不大。但短期最大的收益我认为是可以让你独立完成一个项目，比如自己开发一个完整的小程序。<br></p><p>不求人的感觉，真的很好。想想，接个外包项目，以前要分人一半，现在你自己照单全收，棒不棒；自己有个好的idea，挽起袖子就是干，爽不爽。<br></p><p>开个玩笑。但独立完成项目对于每个开发者来说，意义确实太挺重大的。这并不是外包只拿一半的问题，而是程序员价值的问题。能独立开发意味着你具备了不求人，不受人限制，甚至是未来独立工作、创业的可能性；独立开发也可以让你去践行自己的各种想法，不再因为好的想法由于不懂服务端而不能落地；独立开发也可以增强你编程的成就感，弄个项目只有fake的假数据有啥意思。<br></p><p>能自己独立做一个完整的Web项目，感觉就像一个熬了几个通宵的人，洗了个热水澡，伸了一个很爽的懒腰，舒服到骨子里去了。<br></p><p>中期来看，学习服务端编程，符合前端要将“传统后端”赶尽杀绝的气势。赶尽杀绝是不可能的，数据和高并发的架构设计依然是传统服务端开发者的领地。但前端现在的发展确实迫使web开发呈现出了”后端靠后，前端靠中“的趋势。服务端蜕化（不是退化，这种变化是良性的）成数据的提供者，大量的业务与数据合并交给前端来处理，这也是三大框架流行的一个因素。前端的重要性愈发明显。<br></p><p>现在的前后端界限非常的模糊。在中大型的项目中，整体架构是三层的，而不是典型的前后双层的。”后端更后“表达了传统的后端将蜕化到纯数据管理的角色，也就是我们说的“服务”的角色，它只提供比较干净的数据，而数据的整合，传输给前端的最终数据模型，都将由前端开发者自己定义。<br></p><p><strong>简单点来说，前端开发者需要会写“API”接口</strong>。前端需要什么数据结构，前端开发者自己是最清楚的，所以业务数据结构的定义交给前端开发者是比较好的做法，这也是为什么很多中大型项目都有“中间层”这个概念。后端是微服务，专心做并发、性能与数据一致性；中间层整合成业务数据，并向前端提供API输出数据。<br></p><p>你成天喷服务端接口垃圾。好！你自己来写！<br></p><p>长期来看，30岁，算了，算35岁，是一个挺难的点。而这一点对于前端开发者来说尤为具有不确定性。<br></p><p>30来岁还能踏踏实实任劳任怨和大把大把年轻人比赛写代码的人真的不多。别听那些跟你说，50岁还能写代码的鬼话。50岁写代码，那可以是因为兴趣，但绝对不能是因为生活。就像我没事儿画会儿画，那是陶冶情操，靠画画生活，我怕不是要饿死。<br></p><p>对于一个程序员来说，逐步走向技术管理/技术总监的路是比较靠谱的一条程序员之路。不是说，35岁后你就不能写代码了，而是35岁之后，只写代码啥都不管的人，你所贡献的价值必定达不到你35岁时的薪资要求。薪资达不到，怎么平衡而立之年”老男人“的自尊心，又如何负担沉重的家庭负担？这个年纪的人需要做团队的决策者，给团队提供超越技术的价值。<br></p><p>不要类比尤大这种星光一样的人物，这并不多见。换个角度，能做出点名气的，混的还不错的，哪个是一点服务端都不懂的呢？<br></p><p>业界有一条不成文的定律，谁离数据更近，谁才有话语权。一个公司掌控技术全局的人必然是偏”后“的。所以我们可以看到大多数公司的核心技术管理者都是服务端出身，纯前端出身完全不懂服务端的CTO/技术总监，少之又少。但只懂服务端，完全不知道啥是三大框架的技术总监遍地都是。是不是不公平？但这就是现状。<br></p><p>不是前端就不能做技术总监/CTO，而是前端独立发展的时间太短。纯前端入门编程，在过去是没有的，绝大多数年纪在30岁以上的都是Java/C#/PHP语言入门编程的。所以，纯前端能否胜任全局的技术管理者，还无法得到有效的验证。<br></p><p>所以35岁这道坎，前端开发者怎么迈过去，还是个未知数。尽可能向服务器靠一靠，是一个不错的选择。反正也不是让你精通服务器开发，也不是让你去搞高并发分布式，但你必须要了解，要能自己独立做做中小项目。<br></p><p>退一万步讲，熟悉服务端API的开发绝对是面试加分项。<br></p><p>以上建议仅针对走技术路线的同学，未来要去做生意的、搞艺术的，或者家里有矿的，不在建议范围内。<br></p><p>此外，学习服务端编程也不是只有<a href=\"https://coding.imooc.com/class/342.html?mc_marking=3bdbadf15a609d995ceabd59428f0f79&mc_channel=shouji\" target=\"_self\">Node.js</a>这一个方向，事实上，如果你心大一点，我觉得Python比Node.js更好，反正这两兄弟都差不多，服务端都搞不过Java。但如果你不想学其他语言，Node.js是你最低成本进阶服务端开发的选择。学一门语言并不是像你想象中的那么容易，如果会JavaScript，选择继续依附这个语言也挺好，至少你不用担心它”死“掉。<br></p><p>前端是框架竞争太残酷，但JavaScript一统天下；而服务端是语言竞争太残酷，昨天还是”世界上最好的语言”，今天就莫名其妙被唱衰了，我他喵的也不知道为啥。青出于蓝胜于蓝到未必，那大概就是一代新人胜旧人吧。<br></p><p>好了，最后要详细讲下课程。<a href=\"https://coding.imooc.com/class/342.html?mc_marking=3bdbadf15a609d995ceabd59428f0f79&mc_channel=shouji\" target=\"_self\"><strong>《</strong><strong>纯正商业应用——Node.js Koa2开发微信小程序后端》</strong></a>到底讲了什么？Node.js有三大应用，前端工程化、Web开发和中间层。本课程主要是讲最为实用的Koa Web开发，并会给大家讲解中间层的概念和意义（不是重点）。工程化和Node.js原生接口基本没讲。<br></p><p><strong>1. </strong>    新课程在业务上将配套我去年的小程序课程<a href=\"https://coding.imooc.com/class/251.html?mc_marking=bea1182dc0a4f4e99b7531fb2e143357&mc_channel=shouji\" target=\"_self\">《纯正商业应用——微信小程序开发实战》</a>，完成《旧岛小样》小程序的服务端开发，帮助同学们对完成完整的项目。前后分离，非必须配套购买，但在前端课程中讲过的知识点不会在新课程中重复。比如回调、Promise、部分ES语法。如果JS基础不好，还是建议看看前端课程。<br></p><p>当然，这都是业务。但熟悉我课程的同学应该知道，我的课，从来不以业务为主。编程思维、优质代码、更好的应用框架才是课程的核心。<br></p><p><strong>2.  </strong>  在新课程中，我们将二次开发KOA。说实话，KOA简直就是裸奔，精简的让人发指。我们当然不能裸奔，所以我们必须穿上漂亮的衣服，舒舒服服的去逛街。二次开发是非常要必要的。我说的二次开发并仅仅只是用上koa-body-parser，koa-router，koa-static这些常见的必备中间件。我们需要巧妙使用koa-router分离路由；需要做路由的自动加载来偷懒；需要编写Lin-Validator中间件来构建验证层；需要编写全局异常处理中间件；需要为每个错误编码还需要为权限编写中间件。<br></p><p>很多同学应该知道egg.js这个知名的Koa框架，但本课程解决的问题是egg.js没有解决的。事实上egg.js给出的只是一个企业级别的框架，但并没有给出像TP、SpringBoot、Flask框架中那些及其有用工具类、校验器、专门针对API优化的异常处理，甚至ORM层也没有给出范例代码。因为目标不一样，egg.js给出的是一个宏大的架子，怎么写代码并没有限定。但我的这门新课程给出的是一套小而优雅的Web API解决方案，我始终认为对于项目开发，没有选择就是最好的选择，先让自己开发更有效率是重中之重。有兴趣的同学，可以在未来把这门课程中代码的写法、工具类移植到egg.js中，两全其美。<br></p><p><strong>3. </strong>   课程中少不了要深入理解下Koa三件套：中间件、洋葱模型、async和await。这个应该都被讲烂了，但新课中会让大家知道：</p><ul class=\" list-paddingleft-2\"><li><p>为什么一定要保证洋葱模型？不保证洋葱模型的后果是什么？</p></li><li><p>Koa中的中间件调用到底是同步还是异步？是不是一定要在中间件调用时加上async和await？不加又能怎样？</p></li><li><p>asnyc和await大家都会用，但当我们面临复杂的异步嵌套调用的时候，当我们面对Promise的时候，如何转化成async和await呢？await的本质到底是什么呢？</p></li></ul><p>相信你听完课程后会有一些不同的理解。<br></p><p><strong>4.  </strong>  异步编程模型。排除语言的门槛，Node.js其实相对于Python、PHP等动态语言的同步框架，编程难度是比较高的。async和await降低了异步的难度，但是异步编程依然非常容易出错，尤其是在链式嵌套调用和异步异常处理上。这也是本课程要讲的重点。<br></p><p><strong>5.</strong>    Node.js中间层的概念。虽然新课程不是以中间层为主的项目，但对于Node.js中间层这个重要的应用还是必须要讲讲的。由于新课程需要调用后端的数据服务，所以刚好可以体现中间层的概念。<br></p><p><strong>6.</strong>    Sequelize 以ORM的方式操作MySQL。没有选择MongoDB。一个公司不可能招聘一个只懂MongoDB不懂关系型数据库的后端开发者。可以不学MongoDB，但是不能不学关系型数据库。不懂关系型数据库，谈不上入门了服务端。当然，如果你Mongo+MySQL文体两开花，那更好。<br></p><p><strong>7. </strong>   JSON序列化。凡是要做API，必然要给出一个灵活的JSON序列化方案，新课程讲给出几个层级的序列化方案来，包括Sequelize实体层，Scope层，Koa层。<br></p><p><strong>8.</strong>  与微信小程序的对接方案，这里涉及到令牌的处理与无感知登录方案。小程序中的无感知方案和Web有所差异，它更简单一些。<br></p><p><strong>9. </strong> 加强对JS这个语言的应用和理解。异步编程太能体现JS的特点了；原型链的理解也是本课程的一个重点。<br></p><p>最后，是最重要的一点。<strong>整个课程的Koa核心库构建思路其实来源于Lin-CMS-Koa这个开源项目</strong>。换句话说，学完这门课程，基本上入门了Lin-CMS的服务端开发，因为从接口到写法，新课程都和Lin-CMS保持同步。事实上我们推出Lin-CMS-KOA就是为了让前端开发者能够独立完成一整套CMS，必须是一体化的JS技术栈。<br></p><p>当然，Lin-CMS前端是Vue构建，如果还不了解Vue的同学，慕课网黄轶老师和DellLee老师的Vue课是绝佳的选择。<br></p><p>赶在新课程上线的前一天，我们发布了Lin-CMS Vue/Koa/Flask的beta稳定版。新版本重写了路由机制，优化UI布局方案，新版UI看起来更加清爽整洁。未来的Java版本也已经提上了日程。<br></p><p><br></p><p><img class data-ratio=\"0.5604166666666667\" data-class=\"lazyload\" src=\"https://mmbiz.qpic.cn/mmbiz_png/E9CyEN06ol5eEY2XDkdSt1g8LxjZEHNdWPJn2UKgTAzib2G1icHw34KQicUeJJbYt5YGdkE12f41kfsfUcKuE2t8A/640?wx_fmt=png\" data-original=\"https://mmbiz.qpic.cn/mmbiz_png/E9CyEN06ol5eEY2XDkdSt1g8LxjZEHNdWPJn2UKgTAzib2G1icHw34KQicUeJJbYt5YGdkE12f41kfsfUcKuE2t8A/640?wx_fmt=png\" data-type=\"png\" data-w=\"1920\" height=\"auto\" width=\"2558\" _width=\"677px\" crossorigin=\"anonymous\" data-fail=\"0\" style=\"width:100%;\" title alt=\"https://img3.sycdn.imooc.com/5ccfad2a00014b1225581434.jpg\">       </p><p><br></p><p>demo传送门：</p><p> <a href=\"http://face.cms.7yue.pro\" _class=\"lazyload\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" data-original=\"http://face.cms.7yue.pro\">http://face.cms.7yue.pro</a> </p><p><br></p><p>github传送门：</p><p><a href=\"https://github.com/TaleLin\" _class=\"lazyload\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" data-original=\"https://github.com/TaleLin\">https://github.com/TaleLin</a><br> </p><p><br></p><p>感谢一路有你们！祝你们前程似锦，快意人生！</p>\n\t\t\t\t\t",
                "cover": [
                    "https://img1.sycdn.imooc.com/5ccfac620001f8d405000344.jpg",
                    "https://mmbiz.qpic.cn/mmbiz_png/E9CyEN06ol5eEY2XDkdSt1g8LxjZEHNdWPJn2UKgTAzib2G1icHw34KQicUeJJbYt5YGdkE12f41kfsfUcKuE2t8A/640?wx_fmt=png"
                ],
                "mode": "image"
            },
            {
                "id": "294509",
                "title": "为什么说要学习全新的原生 JavaScript？",
                "browse_count": 9167,
                "collection_count": 50,
                "comments_count": 8,
                "author": {
                    "id": "5027812",
                    "author_name": "快乐动起来呀",
                    "avatar": "//img2.sycdn.imooc.com/54584cb50001e5b302200220-160-160.jpg",
                    "status": "normal"
                },
                "classify": "前端开发",
                "thumbs_up_count": 50,
                "create_time": "2019.10.30 00:05",
                "content": "\n\t\t\t\t\t\t<view class=\"cl-preview-section\"><h3 align=\"center\">开场白</h3>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/389.html?mc_marking=789c4437ab8c45726819b836e16f034e&mc_channel=shouji\">JavaScript</a> 是前端开发工程师最重要的技能，没有之一。在 Vue.js、React.js、Koa、Echarts 等框架风靡一时的背景下，原生的 JavaScript 就可以被抛弃了吗？答案是否定的。</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">typeof</span> 10n<span class=\"token punctuation\">;</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>请看下这个代码的执行结果是什么？（能一眼看出结果的同学请迅速离场）。</p>\n</view><view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"//img1.sycdn.imooc.com/5db855c800013c6102680255.jpg\" data-original=\"//img1.sycdn.imooc.com/5db855c800013c6102680255.jpg\" alt=\"图片描述\" style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>这个正确的直接结果是：<a href=\"https://coding.imooc.com/class/389.html?mc_marking=789c4437ab8c45726819b836e16f034e&mc_channel=shouji\">bigint</a>。</p>\n</view><view class=\"cl-preview-section\"><p>那么 <a href=\"https://coding.imooc.com/class/389.html?mc_marking=789c4437ab8c45726819b836e16f034e&mc_channel=shouji\">bigint</a> 是用来解决什么问题的呢？从字面意思就能猜出 big 的含义，我们知道 Number 基本类型可以精确表示的最大整数是 2^53，如果超出了这个范围那就会出错了，所以在 ES10 提出了 bigint 数据类型来解决这个问题。</p>\n</view><view class=\"cl-preview-section\"><p>开场白结束了，我的观点也表达完了：<strong>原生能力是框架所不能取代的</strong>。</p>\n</view><view class=\"cl-preview-section\"><h3 align=\"center\">辩证关系</h3>\n</view><view class=\"cl-preview-section\"><p>此时此刻，很多同学还处于朦胧中：原生JavaScript不能被框架所取代，那他俩的关系是什么？需要我二选一吗？</p>\n</view><view class=\"cl-preview-section\"><blockquote>\n<p>  Javascript框架是指以Javascript语言为基础搭建的编程框架</p>\n</blockquote>\n</view><view class=\"cl-preview-section\"><p>这是百度百科的定义，换句话说框架本质上还是原生的 JavaScript，如果 JavaScript 不具备的能力，框架也注定无能为力。其次，框架更注重的是效率的提升而非能力。比如 Vue.js 让大家编写组件更容易了让我们写业务的开发效率提升了，但是不能说 Vue.js 让原生 JavaScript 的能力增强了。反过来说原生 JavaScript 能在框架之上做什么？那就是写业务逻辑了或者补充框架能力（插件）。比如我们经常使用 Webpack 框架，如果我们想写一个 Webpack 插件还是需要用原生 JavaScript 来编写的。当然就算我们使用 Vue、React 这样的框架，业务逻辑也是需要原生 JavaScript来写的。</p>\n</view><view class=\"cl-preview-section\"><h3 align=\"center\">JS升级：ES6</h3>\n</view><view class=\"cl-preview-section\"><p>前端开发者一路从 ES3 写到 ES5，2015年发布了 <a href=\"https://coding.imooc.com/class/389.html?mc_marking=789c4437ab8c45726819b836e16f034e&mc_channel=shouji\">ES6</a> 让原生 JavaScript 能力大幅提升，Class、Proxy、Generator等专用语法和能力标准化，也逐步得到各大浏览器的兼容。对于前端开发者来说我们可以极度精简代码和提升开发效率，不妨看下：</p>\n</view><view class=\"cl-preview-section\"><blockquote>\n<p>“初始化一个数组，要求数组的长度是 5，每个元素的默认值是 0”</p>\n</blockquote>\n</view><view class=\"cl-preview-section\"><p>这道题看似非常简单，我们可能会这样来写代码：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\"><</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  arr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>可是如果你学习过 ES6 的语法，就会知道 Array 新增的原型对象方法上有个 fill 的 API，它可以轻松实现这个题目，代码如下：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>这就是新的语法赋予 JavaScript 新的能力，如果我们不持续学习新的语法，写出来的代码很难是最简、最优雅、性能最好。当然，阅读其他同学或者开源代码的时候也不一定能看懂。那么 <a href=\"https://coding.imooc.com/class/389.html?mc_marking=789c4437ab8c45726819b836e16f034e&mc_channel=shouji\">ES6</a> 到底新增或者增强了哪些能力呢？我们来看下图谱：</p>\n</view><view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"//img1.sycdn.imooc.com/5d8f69b50001377b44544894.png\" data-original=\"//img1.sycdn.imooc.com/5d8f69b50001377b44544894.png\" alt style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>从这个图谱不能看出 ES6 增加了很多新的语法，比如 Class、Generator、Proxy、Iterator 等。它们可以解决类、异步、代理、自定义遍历等功能。不如我们再来看个小示例：</p>\n</view><view class=\"cl-preview-section\"><blockquote>\n<p>实现类与继承。</p>\n</blockquote>\n</view><view class=\"cl-preview-section\"><p>在 ES6 之前实现类与继承都是借助函数来实现的，在继承方面也是利用原型链。代码如下：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Component</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'id'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    writable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> com <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncom<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span> <span class=\"token comment\">// jklls</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>这段代码的含义是定义一个组件类，类定义了一个属性 id，这个 id 是随机、只读的。ES6 有了专门的语法来定义类。</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'id'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      writable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> com <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncom<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>在语义上看 ES6 的写法更容易读懂。不信，我们在看下继承的写法：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Component</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'id'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    writable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">SubComponent</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Component<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\nSubComponent<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> Component<span class=\"token punctuation\">.</span>prototype\n<span class=\"token keyword\">const</span> com <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SubComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncom<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><hr></view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'id'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      writable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SubComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> com <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SubComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncom<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>上下代码对比可以看出来 ES6 的方式要舒服很多，也更容易阅读。借助这个题我们再来思考 ES6 这个写法还能继续优化吗？比如 Object.defineProperty 方法在构造函数里显得那么格格不入。有没有更优雅的写法呢？不妨试试 ES6 新的语法 Proxy？</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>proxy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      id<span class=\"token punctuation\">:</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">id</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>proxy<span class=\"token punctuation\">.</span>id\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> com <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncom<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>利用 Proxy 和 Class getter 方式就能保证 id 是只读的，在 proxy 实例化的时候也能保证 id “随机”、“唯一”。有同学会说这个代码有漏洞，proxy 还可以修改会导致 id 也可以被修改。说的没错，但是低估了 proxy 的能力，你再看：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>proxy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      id<span class=\"token punctuation\">:</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">set</span> <span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">id</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>proxy<span class=\"token punctuation\">.</span>id\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> com <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncom<span class=\"token punctuation\">.</span>proxy<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">4</span>\ncom<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>要知道 proxy 下面可以放很多跟 id 一样的内容，这样我们就不会一个一个用 Object.defineProperty 去显示的定义“只读”。用 class getter + proxy 的方式写起来“不露痕迹”，大家是否享受这种写法呢？当然，proxy 还有很多用武之地，比如把保护数据、数据校验等等。</p>\n</view><view class=\"cl-preview-section\"><p>如果大家没过瘾，我们再看一个更强大的功能：<a href=\"https://coding.imooc.com/class/389.html?mc_marking=789c4437ab8c45726819b836e16f034e&mc_channel=shouji\">自定义遍历</a>。</p>\n</view><view class=\"cl-preview-section\"><blockquote>\n<p>“我们数据库里存放着很多图书的作者，这些作者按照图书的类别进行分类，现在想遍历所有作者该怎么办？”</p>\n</blockquote>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">let</span> authors <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  allAuthors<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    fiction<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token string\">'Agatha Christie'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'J. K. Rowling'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'Dr. Seuss'</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    scienceFiction<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token string\">'Neal Stephenson'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'Arthur Clarke'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'Isaac Asimov'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'Robert Heinlein'</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    fantasy<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token string\">'J. R. R. Tolkien'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'J. K. Rowling'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'Terry Pratchett'</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>我们希望可以对 authors 进行遍历并得到所有作者的名单。</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> author <span class=\"token keyword\">of</span> authors<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>author<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>本希望可以这做可是浏览器报错了，告诉我们 authors 是不可遍历的。那我们只能通过遍历所有 key 的方式来实现：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> key <span class=\"token keyword\">in</span> authors<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> k <span class=\"token keyword\">in</span> authors<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    r <span class=\"token operator\">=</span> r<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>authors<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// [\"Agatha Christie\", \"J. K. Rowling\", \"Dr. Seuss\", \"Neal Stephenson\", \"Arthur Clarke\", \"Isaac Asimov\", \"Robert Heinlein\", \"J. R. R. Tolkien\", \"J. K. Rowling\", \"Terry Pratchett\"]</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>虽然用 <a href=\"https://coding.imooc.com/class/280.html?mc_marking=636a3b779c984db5fc3d979d3793d71c&mc_channel=shouji\">ES5</a> 的方式实现了，可是我们仍希望用 for…of 的方式来实现，简单便捷。<a href=\"https://coding.imooc.com/class/280.html?mc_marking=636a3b779c984db5fc3d979d3793d71c&mc_channel=shouji\">ES6</a> 增加了 Iterator 让任意数据结构可以实现自定义遍历器。直接上代码：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\">authors<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> allAuthors <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>allAuthors\n  <span class=\"token keyword\">let</span> keys <span class=\"token operator\">=</span> Reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ownKeys</span><span class=\"token punctuation\">(</span>allAuthors<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">let</span> values <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">next</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>values<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>keys<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          values <span class=\"token operator\">=</span> allAuthors<span class=\"token punctuation\">[</span>keys<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n          keys<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        done<span class=\"token punctuation\">:</span> <span class=\"token operator\">!</span>values<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">,</span>\n        value<span class=\"token punctuation\">:</span> values<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>我们只需要对 authors 这个数据结构增加 Iterator 遍历器接口即可用 for…of 的方式来遍历了，浏览器不再报错了。有没有很惊艳？</p>\n</view><view class=\"cl-preview-section\"><h3 align=\"center\">JS升级：ES7+</h3>\n</view><view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"//img1.sycdn.imooc.com/5d8f699a0001564612000675.jpg\" data-original=\"//img1.sycdn.imooc.com/5d8f699a0001564612000675.jpg\" alt=\"图片描述\" style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>其实 ES6 之后 ES7、ES8、ES9、ES10相继诞生，它们让原生 JavaScript 的能力再次提升。</p>\n</view><view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"//img1.sycdn.imooc.com/5d8f69de0001551540782346.png\" data-original=\"//img1.sycdn.imooc.com/5d8f69de0001551540782346.png\" alt=\"图片描述\" style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>虽然从 ES7 开始没有像 ES6 那样带来大版本的改动，但是能力的提升仍不可忽视。正则表达式是我们日常开发经常使用的技能，从 ES9 开始就支持正则表达式的分组命名捕获。</p>\n</view><view class=\"cl-preview-section\"><blockquote>\n<p>  在指定的日期字符串中提取年、月、日数据</p>\n</blockquote>\n</view><view class=\"cl-preview-section\"><p>在ES9之前不得不这样做：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">let</span> t <span class=\"token operator\">=</span> <span class=\"token string\">'2019-06-07'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/(\\d{4})-(\\d{2})-(\\d{2})/</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 2019</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 06</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 07</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>现在就可以这样做了：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'2019-06-07'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// [\"2019-06-07\", \"2019\", \"06\", \"07\", index: 0, input: \"2019-06-07\", groups: {…}]</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>这段代码的返回值 groups 已经是 Object 了，具体的值是：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\">groups<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>year<span class=\"token punctuation\">:</span> <span class=\"token string\">\"2019\"</span><span class=\"token punctuation\">,</span> month<span class=\"token punctuation\">:</span> <span class=\"token string\">\"06\"</span><span class=\"token punctuation\">,</span> day<span class=\"token punctuation\">:</span> <span class=\"token string\">\"07\"</span><span class=\"token punctuation\">}</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>这个 Object 的 key 就是正则表达式中定义的，也就是把捕获分组进行了命名。想获取这些捕获可以这样做：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">let</span> t <span class=\"token operator\">=</span> <span class=\"token string\">'2019-06-07'</span><span class=\"token punctuation\">.</span><span class=\"token function\">match</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// [\"2019-06-07\", \"2019\", \"06\", \"07\", index: 0, input: \"2019-06-07\", groups: {…}]</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>groups<span class=\"token punctuation\">.</span>year<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 2019</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>groups<span class=\"token punctuation\">.</span>month<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 06</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>groups<span class=\"token punctuation\">.</span>day<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 07</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>通过这个简单的实例，不难看出<a href=\"https://coding.imooc.com/class/389.html?mc_marking=789c4437ab8c45726819b836e16f034e&mc_channel=shouji\">全新的 JavaScript 语法</a>会改变我们之前书写的习惯，用新的能力解决问题；当然还有很多能力能解决之前搞不定的问题，有没有很期待？</p>\n</view><view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"//img1.sycdn.imooc.com/5db862a00001dcef02550255.gif\" data-original=\"//img1.sycdn.imooc.com/5db862a00001dcef02550255.gif\" alt=\"图片描述\" style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>················<br>\n欢迎关注课程：<br><a href=\"https://coding.imooc.com/class/389.html?mc_marking=789c4437ab8c45726819b836e16f034e&mc_channel=shouji\">《再学JavaScript ES(6-10)全版本语法大全》</a>（新课限时优惠）</p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/315.html?mc_marking=1b4ca998cac4dd155a725dbbaa47cf6a&mc_channel=shouji\">JavaScript版 数据结构与算法</a></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/129.html?mc_marking=1782be68aed014c2e93a5ca131300998&mc_channel=shouji\">前端跳槽面试必备技巧</a></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/280.html?mc_marking=636a3b779c984db5fc3d979d3793d71c&mc_channel=shouji\">Vue全家桶+SSR+Koa2全栈开发美团网</a></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/98.html?mc_marking=270155e6d1a2e60478491e691bedc297&mc_channel=shouji\">ES6零基础教学 解析彩票项目</a></p>\n</view>\n\t\t\t\t\t",
                "cover": [
                    "//img1.sycdn.imooc.com/5db855c800013c6102680255.jpg",
                    "//img1.sycdn.imooc.com/5d8f69b50001377b44544894.png",
                    "//img1.sycdn.imooc.com/5d8f699a0001564612000675.jpg",
                    "//img1.sycdn.imooc.com/5d8f69de0001551540782346.png",
                    "//img1.sycdn.imooc.com/5db862a00001dcef02550255.gif"
                ],
                "mode": "column"
            },
            {
                "id": "293012",
                "title": "领略原生 JavaScript ES6~ES10 的魅力",
                "browse_count": 5415,
                "collection_count": 49,
                "comments_count": 11,
                "author": {
                    "id": "5027812",
                    "author_name": "快乐动起来呀",
                    "avatar": "//img2.sycdn.imooc.com/54584cb50001e5b302200220-160-160.jpg",
                    "status": "normal"
                },
                "classify": "前端开发",
                "thumbs_up_count": 49,
                "create_time": "2019.09.28 22:11",
                "content": "\n\t\t\t\t\t\t<view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"//img1.sycdn.imooc.com/5d8f699a0001564612000675.jpg\" data-original=\"//img1.sycdn.imooc.com/5d8f699a0001564612000675.jpg\" alt=\"图片描述\" style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>作为<a href=\"https://coding.imooc.com/class/280.html?mc_marking=636a3b779c984db5fc3d979d3793d71c&mc_channel=shouji\">前端开发工程师</a>，盲目追逐框架似乎有点舍本逐末，要知道基本功才是硬核。<a href=\"https://coding.imooc.com/class/280.html?mc_marking=636a3b779c984db5fc3d979d3793d71c&mc_channel=shouji\">JavaScript</a> 的语法这几年一直在更新，不管我们是框架的核心开发者还是业务重塑者，学习下最新的 JavaScript 语法和能力是非常有好处的。下面我们通过几个小示例来看下新语法的强大之处：</p>\n</view><view class=\"cl-preview-section\"><blockquote>\n<p>“初始化一个数组，要求数组的长度是 5，每个元素的默认值是 0”</p>\n</blockquote>\n</view><view class=\"cl-preview-section\"><p>这道题看似非常简单，我们可能会这样来写代码：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\"><</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  arr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>可是如果你学习过 ES6 的语法，就会知道 Array 新增的原型对象方法上有个 fill 的 API，它可以轻松实现这个题目，代码如下：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token function\">Array</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">fill</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>这就是新的语法赋予 JavaScript 新的能力，如果我们不持续学习新的语法，写出来的代码很难是最简、最优雅、性能最好。当然，阅读其他同学或者开源代码的时候也不一定能看懂。那么 ES6 到底新增或者增强了哪些能力呢？我们来看下图谱：</p>\n</view><view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"//img1.sycdn.imooc.com/5d8f69b50001377b44544894.png\" data-original=\"//img1.sycdn.imooc.com/5d8f69b50001377b44544894.png\" alt style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>从这个图谱不能看出 ES6 增加了很多新的语法，比如 Class、Generator、Proxy、Iterator 等。它们可以解决类、异步、代理、自定义遍历等功能。不如我们再来看个小示例：</p>\n</view><view class=\"cl-preview-section\"><blockquote>\n<p>实现类与继承。</p>\n</blockquote>\n</view><view class=\"cl-preview-section\"><p>在 ES6 之前实现类与继承都是借助函数来实现的，在继承方面也是利用原型链。代码如下：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Component</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'id'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    writable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> com <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncom<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span> <span class=\"token comment\">// jklls</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>这段代码的含义是定义一个组件类，类定义了一个属性 id，这个 id 是随机、只读的。ES6 有了专门的语法来定义类。</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'id'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      writable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> com <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncom<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>在语义上看 ES6 的写法更容易读懂。不信，我们在看下继承的写法：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Component</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n  Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'id'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    writable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">SubComponent</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  Component<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\nSubComponent<span class=\"token punctuation\">.</span>prototype <span class=\"token operator\">=</span> Component<span class=\"token punctuation\">.</span>prototype\n<span class=\"token keyword\">const</span> com <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SubComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncom<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><hr></view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n    Object<span class=\"token punctuation\">.</span><span class=\"token function\">defineProperty</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'id'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      writable<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SubComponent</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> com <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SubComponent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncom<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>上下代码对比可以看出来 ES6 的方式要舒服很多，也更容易阅读。借助这个题我们再来思考 ES6 这个写法还能继续优化吗？比如 Object.defineProperty 方法在构造函数里显得那么格格不入。有没有更优雅的写法呢？不妨试试 ES6 新的语法 Proxy？</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>proxy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      id<span class=\"token punctuation\">:</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">id</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>proxy<span class=\"token punctuation\">.</span>id\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> com <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncom<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>利用 Proxy 和 Class getter 方式就能保证 id 是只读的，在 proxy 实例化的时候也能保证 id “随机”、“唯一”。有同学会说这个代码有漏洞，proxy 还可以修改会导致 id 也可以被修改。说的没错，但是低估了 proxy 的能力，你再看：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>proxy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      id<span class=\"token punctuation\">:</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token number\">36</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">set</span> <span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">get</span> <span class=\"token function\">id</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>proxy<span class=\"token punctuation\">.</span>id\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> com <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Component</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncom<span class=\"token punctuation\">.</span>proxy<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">4</span>\ncom<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>com<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>要知道 proxy 下面可以放很多跟 id 一样的内容，这样我们就不会一个一个用 Object.defineProperty 去显示的定义“只读”。用 class getter + proxy 的方式写起来“不露痕迹”，大家是否享受这种写法呢？当然，proxy 还有很多用武之地，比如把保护数据、数据校验等等。</p>\n</view><view class=\"cl-preview-section\"><p>如果大家没过瘾，我们再看一个更强大的功能：自定义遍历。</p>\n</view><view class=\"cl-preview-section\"><blockquote>\n<p>“我们数据库里存放着很多图书的作者，这些作者按照图书的类别进行分类，现在想遍历所有作者该怎么办？”</p>\n</blockquote>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">let</span> authors <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  allAuthors<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    fiction<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token string\">'Agatha Christie'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'J. K. Rowling'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'Dr. Seuss'</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    scienceFiction<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token string\">'Neal Stephenson'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'Arthur Clarke'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'Isaac Asimov'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'Robert Heinlein'</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    fantasy<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n      <span class=\"token string\">'J. R. R. Tolkien'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'J. K. Rowling'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'Terry Pratchett'</span>\n    <span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>我们希望可以对 authors 进行遍历并得到所有作者的名单。</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> author <span class=\"token keyword\">of</span> authors<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>author<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>本希望可以这做可是浏览器报错了，告诉我们 authors 是不可遍历的。那我们只能通过遍历所有 key 的方式来实现：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> key <span class=\"token keyword\">in</span> authors<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> k <span class=\"token keyword\">in</span> authors<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    r <span class=\"token operator\">=</span> r<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>authors<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span>\n  <span class=\"token comment\">// [\"Agatha Christie\", \"J. K. Rowling\", \"Dr. Seuss\", \"Neal Stephenson\", \"Arthur Clarke\", \"Isaac Asimov\", \"Robert Heinlein\", \"J. R. R. Tolkien\", \"J. K. Rowling\", \"Terry Pratchett\"]</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>虽然用 <a href=\"https://coding.imooc.com/class/280.html?mc_marking=636a3b779c984db5fc3d979d3793d71c&mc_channel=shouji\">ES5</a> 的方式实现了，可是我们仍希望用 for…of 的方式来实现，简单便捷。<a href=\"https://coding.imooc.com/class/280.html?mc_marking=636a3b779c984db5fc3d979d3793d71c&mc_channel=shouji\">ES6</a> 增加了 Iterator 让任意数据结构可以实现自定义遍历器。直接上代码：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-js\"><code class=\"prism language-js\">authors<span class=\"token punctuation\">[</span>Symbol<span class=\"token punctuation\">.</span>iterator<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> allAuthors <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>allAuthors\n  <span class=\"token keyword\">let</span> keys <span class=\"token operator\">=</span> Reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ownKeys</span><span class=\"token punctuation\">(</span>allAuthors<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">let</span> values <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">next</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>values<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>keys<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          values <span class=\"token operator\">=</span> allAuthors<span class=\"token punctuation\">[</span>keys<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n          keys<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n        done<span class=\"token punctuation\">:</span> <span class=\"token operator\">!</span>values<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">,</span>\n        value<span class=\"token punctuation\">:</span> values<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>我们只需要对 authors 这个数据结构增加 Iterator 遍历器接口即可用 for…of 的方式来遍历了，浏览器不再报错了。有没有很惊艳？其实 ES6 之后 ES7、ES8、ES9、ES10相继诞生，它们让原生 JavaScript 的能力再次提升。</p>\n</view><view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"//img1.sycdn.imooc.com/5d8f69de0001551540782346.png\" data-original=\"//img1.sycdn.imooc.com/5d8f69de0001551540782346.png\" alt=\"图片描述\" style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>不学习原生 JavaScript 新技能注定会让我们错过更多魅力之城，一起结对学 <a href=\"https://coding.imooc.com/class/280.html?mc_marking=636a3b779c984db5fc3d979d3793d71c&mc_channel=shouji\">ES6~ES10</a>吧。</p>\n</view><view class=\"cl-preview-section\"><p>·····················<br><strong>欢迎关注课程：</strong></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/315.html?mc_marking=1b4ca998cac4dd155a725dbbaa47cf6a&mc_channel=shouji\">JavaScript版 数据结构与算法</a></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/129.html?mc_marking=1782be68aed014c2e93a5ca131300998&mc_channel=shouji\">前端跳槽面试必备技巧</a></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/280.html?mc_marking=636a3b779c984db5fc3d979d3793d71c&mc_channel=shouji\">Vue全家桶+SSR+Koa2全栈开发美团网</a></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/98.html?mc_marking=270155e6d1a2e60478491e691bedc297&mc_channel=shouji\">ES6零基础教学 解析彩票项目</a></p>\n</view>\n\t\t\t\t\t",
                "cover": [
                    "//img1.sycdn.imooc.com/5d8f699a0001564612000675.jpg",
                    "//img1.sycdn.imooc.com/5d8f69b50001377b44544894.png",
                    "//img1.sycdn.imooc.com/5d8f69de0001551540782346.png"
                ],
                "mode": "column"
            },
            {
                "id": "300475",
                "title": "面试过程中应该避免的几种情况（最后附送前端面试题）",
                "browse_count": 9446,
                "collection_count": 38,
                "comments_count": 8,
                "author": {
                    "id": "4427201",
                    "author_name": "双越",
                    "avatar": "//img2.sycdn.imooc.com/5a9fc8070001a82402060220-160-160.jpg",
                    "status": "normal"
                },
                "classify": "前端开发",
                "thumbs_up_count": 38,
                "create_time": "2020.02.10 22:40",
                "content": "\n\t\t\t\t\t\t<view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/419.html?mc_marking=6cb7d66d14ce48575d233fad0bda38bd&mc_channel=shouji\">前言</a></h2>\n</view><view class=\"cl-preview-section\"><p>2020 春招在即，准备跳槽的同学应该也都在准备中。除了要准备技术知识点之外，还应该知道面试时容易犯的一些错误。</p>\n</view><view class=\"cl-preview-section\"><p>本片文章，我将回顾一下自己作为面试官，曾经面试过的几个负面的案例，分享出来。大家可以作为参考，看看是不是这样做有些不合适。</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/419.html?mc_marking=6cb7d66d14ce48575d233fad0bda38bd&mc_channel=shouji\">案例1 - 深入问题中，誓死不肯放弃</a></h2>\n</view><view class=\"cl-preview-section\"><blockquote>\n<p>永不放弃，不达目的誓不罢休 —— 在面试或者编程时，是不可取的</p>\n</blockquote>\n</view><view class=\"cl-preview-section\"><h3>案例描述</h3>\n</view><view class=\"cl-preview-section\"><p>A 同学来面试，我出的第一个问题是一个有关逻辑、算法的问题，并不是一个什么新技术。按照正常的流程，A 就说：先让我思考两分钟。我说：可以。</p>\n</view><view class=\"cl-preview-section\"><p>然后，两分钟，三分钟，四分钟，五分钟，过去了。期间我看他写、算很认真，没好意思打断他。到了五分钟，我问：有思路了吗？他答：再给我两分钟，我很快就做出来了。</p>\n</view><view class=\"cl-preview-section\"><p>再然后，两分钟，三分钟，四分钟，五分钟，过去了。我再问：有思路了吗？他答：再等一下，我一定要把这道题目做出来！！！（我没注意他说这句话是否咬着牙说的）</p>\n</view><view class=\"cl-preview-section\"><p>15 分钟过去了，依然没有解答出来，我不得不<strong>强制叫停</strong>，真的需要强制。然后给他解释这道问题，正确的解题思路是什么。但是 —— 他又开始跟我掰扯，问他这种思路对不对 …… 最后，20 多分钟过去了，这道题才算结束。<strong>然而，我的面试时间只有 60 分钟</strong>。</p>\n</view><view class=\"cl-preview-section\"><h3>案例分析</h3>\n</view><view class=\"cl-preview-section\"><p>一道题的成败，决定不了你能否面试通过，搞不出来那就放弃吧，没关系的。而你在第一道题就浪费 20 多分钟，剩下的时间就不够全面考察你的其他能力。毕竟面试官也有其他事情要做，不能一直陪着你。</p>\n</view><view class=\"cl-preview-section\"><p>更重要的是，<strong>遇到问题第一时间应该选择的是沟通，而不是自己攻坚</strong>。面试时遇到问题，可以向面试官求助，让他提示一下。工作中遇到问题，像这样自己攻坚是绝对不可取的，项目将会因为你的攻坚而延期。</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/419.html?mc_marking=6cb7d66d14ce48575d233fad0bda38bd&mc_channel=shouji\">案例2 - 生无可恋 & 无所谓的脸</a></h2>\n</view><view class=\"cl-preview-section\"><blockquote>\n<p>公司是招程序员，不是招大爷</p>\n</blockquote>\n</view><view class=\"cl-preview-section\"><h3>案例描述</h3>\n</view><view class=\"cl-preview-section\"><p>B 大哥来面试，全程死板着脸，面无表情，生无可恋。一脸什么都不在乎的样子，都不正眼看自己一眼。</p>\n</view><view class=\"cl-preview-section\"><p>而且，在思考、回答问题的时候，也不见他积极主动的思考。拿过一个问题来，看一看觉得会多少就说多少，不会的也不想想、不写写、不思考，就直接说不会。</p>\n</view><view class=\"cl-preview-section\"><h3>案例分析</h3>\n</view><view class=\"cl-preview-section\"><p><strong>在实际做项目过程中，沟通和协作是非常重要</strong>。如果因为个人性格问题，而导致沟通不畅，技术再好也不会考虑。</p>\n</view><view class=\"cl-preview-section\"><p>我们作为一个个体，保持自己的个性，无论是哪方面的个性，都没有问题。但作为一个项目组成员，就不能太有个性。</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/419.html?mc_marking=6cb7d66d14ce48575d233fad0bda38bd&mc_channel=shouji\">案例3 - Vue 生命周期，忘了</a></h2>\n</view><view class=\"cl-preview-section\"><blockquote>\n<p>你说：Vue 生命周期不记得了，但没关系，我再看看两天文档很快就能拿上手的。我想说：既然这么简单，为何不看两天文档再出来面试？也不耽误事儿。</p>\n</blockquote>\n</view><view class=\"cl-preview-section\"><h3>案例描述</h3>\n</view><view class=\"cl-preview-section\"><p>C 同学是一名工作经验比较丰富的程序员，简历也不错，工作背景也很好。只不过，此前一直做其他技术栈，Vue 好久没做了。但是没关系，这种简历我们一样非常喜欢，很欢迎来参加面试。</p>\n</view><view class=\"cl-preview-section\"><p>C 同学如约过来面试，基础知识、设计能力、项目经验都非常好。但是问到 Vue 的一些基本使用时，却答不出来。例如问 Vue 组件生命周期，写不出来，或者能写出来一部分漏掉非常关键的一个生命周期。</p>\n</view><view class=\"cl-preview-section\"><p>然后，C 同学会说：这个好久没做，忘了，再看看文档应该就很快能熟悉起来。</p>\n</view><view class=\"cl-preview-section\"><h3>案例分析</h3>\n</view><view class=\"cl-preview-section\"><p>Vue 是现在最常用的框架之一（还有 React webpack 等等），作为候选人，无论用过没用过，都应该在面试之前去复习、恶补一下。哪怕捡着最关键的地方补一补，读一读文档。组件生命周期，是理解 Vue 或者其他框架的核心，面试也是必考的。</p>\n</view><view class=\"cl-preview-section\"><p>明知道是重点内容，面试必考内容，而不去准备。这样眼高手低，会让人担心，入职之后是不是也这样。例如：这个代码很简单，不用写注释了；这个功能很简单，不用写设计方案和单元测试了 ……</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/419.html?mc_marking=6cb7d66d14ce48575d233fad0bda38bd&mc_channel=shouji\">案例4 - 看简历至少是 CTO</a></h2>\n</view><view class=\"cl-preview-section\"><blockquote>\n<p>你那么厉害，干嘛要来搞前端呢？</p>\n</blockquote>\n</view><view class=\"cl-preview-section\"><h3>案例描述</h3>\n</view><view class=\"cl-preview-section\"><p>hr 转来了一份 D 同学的简历，打开一看，满满的三大页。我一看这技能点，真的是全栈中的 VIP 。</p>\n</view><view class=\"cl-preview-section\"><p>从前端到客户端，再到跨端。从后端到数据库，再到运维。从 js 到 java ，再到 python ，最后到 C++ 。从算法，到大数据，再到 AI 。</p>\n</view><view class=\"cl-preview-section\"><p>最后，吓得我没敢邀约。</p>\n</view><view class=\"cl-preview-section\"><h3>案例分析</h3>\n</view><view class=\"cl-preview-section\"><p>也许这 D 同学真的如此 NB ，但是这种水平真的不适合搞前端。但是，如果 D 同学真的有心想要做前端开发，我坚信他的简历一定有水分。</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/419.html?mc_marking=6cb7d66d14ce48575d233fad0bda38bd&mc_channel=shouji\">案例5 - 不想做一线开发</a></h2>\n</view><view class=\"cl-preview-section\"><blockquote>\n<p>绝大部分工作岗位，都是招干活的。所以，要看清岗位要求，再去面试。</p>\n</blockquote>\n</view><view class=\"cl-preview-section\"><h3>案例描述</h3>\n</view><view class=\"cl-preview-section\"><p>E 老哥工作时间很久了，大大小小的公司也都带过，项目经验也很丰富。从基础知识，到框架，再到项目经验，也都比较全面。不能说很优秀，但整体 70-80 分没问题。这已经很不错了。</p>\n</view><view class=\"cl-preview-section\"><p>但面试到最后，他表达说，自己不想再做一线开发了。无论是什么原因吧，反正想做一些管理岗位或者项目经理的角色，想带人。</p>\n</view><view class=\"cl-preview-section\"><p>当然，最后肯定没成功，因为这个岗位招聘的就是一线开发人员。</p>\n</view><view class=\"cl-preview-section\"><h3>案例分析</h3>\n</view><view class=\"cl-preview-section\"><p>其实自己有自己的工作要求，这不是问题，而且是好事儿。但你也要看清楚招聘岗位要求，看看公司想要招什么。否则你来了，折腾了半天，结果双方都浪费时间。</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/419.html?mc_marking=6cb7d66d14ce48575d233fad0bda38bd&mc_channel=shouji\">案例6 - 挑战面试官</a></h2>\n</view><view class=\"cl-preview-section\"><blockquote>\n<p>你是来面试的，是来争取工作机会的，不是来跟面试官争论的。</p>\n</blockquote>\n</view><view class=\"cl-preview-section\"><h3>案例描述</h3>\n</view><view class=\"cl-preview-section\"><p>曾经面试过 F 老哥，记得问到 Vue 原理的一个问题时，我跟他解释这个问题的流程。当我讲到一个非常细节的问题时，他突然兴致起来，跟我说：这个地方你说错了。然后说了自己的答案，还拍着胸脯确定无疑。</p>\n</view><view class=\"cl-preview-section\"><p>说实话，当时我还真有点心虚，难道是我记错了？然后我就嗯啊的答应着，顺着他说。后来我回去查了查，发现自己没记错。</p>\n</view><view class=\"cl-preview-section\"><h3>案例分析</h3>\n</view><view class=\"cl-preview-section\"><p>当然，F 老哥还不算是挑战面试官了，算不上挑战。当然我也是个大大咧咧的人，也不会在乎程序员的技术争论，这很正常。</p>\n</view><view class=\"cl-preview-section\"><p>但是作为候选人，建议你千万不要做任何 善意的/非善意的 ，纠正/挑战 面试官的事情。哪怕他说错了，你就那么听一听，就忍不了了吗？</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/419.html?mc_marking=6cb7d66d14ce48575d233fad0bda38bd&mc_channel=shouji\">最后，附送前端常考的面试题</a></h2>\n</view><view class=\"cl-preview-section\"><p>以下几个问题是面试常考，和社区热议的题目，可以借机对自己做一个小测试。<strong>PS：只有问题没有答案。对问题有疑问的，欢迎给我留言哈。</strong></p>\n</view><view class=\"cl-preview-section\"><h3>Vue 面试题</h3>\n</view><view class=\"cl-preview-section\"><ul><li>v-if 和 v-show 的区别。</li>\n<li>为何 v-for 中使用 key（要说明原理）？</li>\n<li>描述 Vue 生命周期（有父子组件的情况下）。</li>\n<li>Vue 组件通讯的常见方式。</li>\n<li>描述组件渲染和更新的过程（开放型题目，自由发挥）。</li>\n<li>用 Vue 设计一个购物车，请设计组件结构，设计 vuex 数据结构。</li>\n</ul></view><view class=\"cl-preview-section\"><h3>React 面试题</h3>\n</view><view class=\"cl-preview-section\"><ul><li>React 组件通讯的常见方式。</li>\n<li>JSX 本质是什么？</li>\n<li>context 是什么，有何用途？</li>\n<li>shouldComponentUpdate 的深入理解。</li>\n<li>描述 redux 单项数据流。</li>\n<li>setState 是同步还是异步？</li>\n<li>用 React 设计一个 todolist ，请设计组件结构，设计 state 数据结构。</li>\n</ul></view><view class=\"cl-preview-section\"><h3>webpack 面试题</h3>\n</view><view class=\"cl-preview-section\"><ul><li>前度代码为何要进行构建和打包？</li>\n<li>module chunk bundle 分别是什么意思，有何区别？</li>\n<li>loader 和 plugin 的区别。</li>\n<li>webpack 如何实现懒加载？</li>\n<li>webpack 常见性能优化方式（开放型题目，自由发挥）。</li>\n<li>babel-runtime 和 babel-polyfill 的区别。</li>\n</ul></view><view class=\"cl-preview-section\"><p>最后，祝大家都能拿到满意 offer ！</p>\n</view>\n\t\t\t\t\t",
                "cover": [],
                "mode": "base"
            },
            {
                "id": "293310",
                "title": "为何前端面试会考察 nodejs ？",
                "browse_count": 4893,
                "collection_count": 26,
                "comments_count": 5,
                "author": {
                    "id": "4427201",
                    "author_name": "双越",
                    "avatar": "//img2.sycdn.imooc.com/5a9fc8070001a82402060220-160-160.jpg",
                    "status": "normal"
                },
                "classify": "前端开发",
                "thumbs_up_count": 26,
                "create_time": "2019.10.10 21:22",
                "content": "\n\t\t\t\t\t\t<view class=\"cl-preview-section\"><p>相信很多同学学习 <a href=\"https://coding.imooc.com/class/388.html?mc_marking=30fc15cce247df044d234982dbcb15da&mc_channel=shouji\">nodejs</a> 都是为了应对面试，或者看别人学过会了，自己也要学。但是你有没有深入思考过，为何面试时要考察 nodejs ，为何 nodejs 逐渐成为前端程序员的必备技能？</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/388.html?mc_marking=30fc15cce247df044d234982dbcb15da&mc_channel=shouji\">为了你自己？</a></h2>\n</view><view class=\"cl-preview-section\"><p>有些同学可能会说，学习 <a href=\"https://coding.imooc.com/class/388.html?mc_marking=30fc15cce247df044d234982dbcb15da&mc_channel=shouji\">nodejs</a> 会让自己前后端都懂，慢慢成长为全栈工程师，巴拉巴拉 —— 就此打住！</p>\n</view><view class=\"cl-preview-section\"><p>不要一上来就说一些个人的技术理想，虽然能有且坚持技术理想的人也少之又少。<strong>技术的使用，永远都是为了解决问题</strong>，你自己的成长只有你自己关心，公司从来不关心一个普通员工的技术成长。公司也从来不关心你用什么技术，什么语言来实现需求，反正只要高效稳定的做出来，后续能保证扩展、快速迭代即可。</p>\n</view><view class=\"cl-preview-section\"><p>其实大部分公司号称有很多员工培养机制，各种技术分享，各种公款买书。但是经历过的人应该都明白，那些分享基本听完就忘，而且很多大牛的分享都是为了自己的技术 KPI 。公款买书和自己买书，也就为自己省了几十块钱，书买来看不看，还得靠你自己。如果你自己能主动看书，相比于学到的知识还差那几十块钱吗？</p>\n</view><view class=\"cl-preview-section\"><p>总之，公司面试时对于候选人的各种要求，目的都是为了更高效的产出工作，要符合部门或者公司的利益。</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/388.html?mc_marking=30fc15cce247df044d234982dbcb15da&mc_channel=shouji\">为了能了解 server 端合作伙伴</a></h2>\n</view><view class=\"cl-preview-section\"><p>在日常工作中，一个 web 项目都会有前端和 server 端，而日常的项目开发，功能迭代，也都需要前端和 server 端配合完成。所以，server 端的接口人，是前端工程师的重要合作伙伴。</p>\n</view><view class=\"cl-preview-section\"><p>server 端的工作模式是什么，它的输入输出是什么，你如果了解甚至做过，那你们的合作将会效率大增。但是，如果前端完全不了解 <a href=\"https://coding.imooc.com/class/320.html?mc_marking=79eafdd0eb8b5dd4114bdf9b50eae184&mc_channel=shouji\">server</a> 端，同时 server 端也不了解前端，那双方合作起来肯定误会不断。特别是如果项目需求一天一变的情况下，而这种情况并不少见。我们无权要求 server 端必须了解前端，只能要求自己更多的了解 server 端。</p>\n</view><view class=\"cl-preview-section\"><p>例如，在一个项目做技术方案设计和评审时，前端和 server 端要确定接口，一般包括 method、输入和输出格式。还会讨论，某些功能实现到底是前端来做，还是 server 来做，哪个更合适。此时，如果你不知道 server 端如果工作，那在这件事儿上你只能听之任之，任人摆布。如果你了解甚至做过 server 端的话，其中有些不合理的地方你就能提出来，既能展示自己的能力，又能保证项目顺利进行。</p>\n</view><view class=\"cl-preview-section\"><p>再例如，万一遇到什么被甩锅或者撕逼的事儿（这种事儿也并不少见），你了解 server 端和你不知道 server 端，绝对是两种不同的“战争”方式。</p>\n</view><view class=\"cl-preview-section\"><p>nodejs 天生就是给前端程序员做 server 的神器，相比于 php python 等其他语言，让前端程序员更容易的入门并接触 server 端开发。做过 nodejs server 端，你就能知道用 php java python 开发 server 是什么套路，只是语言不一样而已。</p>\n</view><view class=\"cl-preview-section\"><p>因此，在 nodejs 出现或者普及之前，岗位招聘要求也一般会写上“了解一门后端语言者优先录用”之类的话语。</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/388.html?mc_marking=30fc15cce247df044d234982dbcb15da&mc_channel=shouji\">为了能承担更多的工作</a></h2>\n</view><view class=\"cl-preview-section\"><p>前端程序员只能且必须做前端页面吗？同时 server 端只能做后端接口吗？—— 当然不是，我有两个例子：</p>\n</view><view class=\"cl-preview-section\"><ul><li>我呆过的两个大型互联网公司，都见过一些测试平台，是由测试人员开发并维护的</li>\n<li>Angular 最初就是几个搞 java 的人写出来的，所以很多概念前端人员都看不懂</li>\n</ul></view><view class=\"cl-preview-section\"><p>其实作为公司，作为领导，他们从来都不会限制自己的员工或者下属部门的工作范围，返回会激发他们的创造性，恨不得什么事儿你都能搞定 —— 当然也得保证可靠性，不能胡来。</p>\n</view><view class=\"cl-preview-section\"><p>我们一个前端部门，难道所有的接口都必须依赖于 server 部门的人来开发吗？难道所有的产品也都必须 server 部门的人来配合吗？—— 这个是不一定的。一般来说，公司核心业务的接口肯定必须由 server 部门来统一维护，但是一些其他的工具性或者 CMS 类型的产品，业务复杂度不高，我们完全可以自己来闭环。一些事情能自己闭环，对于公司来说就是节省了人力，而且解耦了部门之间没必要的业务联系，也就提高了工作效率。</p>\n</view><view class=\"cl-preview-section\"><p>另外，在一些大公司，人员较多，组织层次较多，业务复杂，领导也多。这种情况下，领导之间占地盘或者抢地盘就很正常了，所以此时更需要员工是“全才”。有些比较看好的项目，只要上层领导审批通过，自己部门的人就悄悄做了，不需要其他组来配（抢）合（食）。</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/388.html?mc_marking=30fc15cce247df044d234982dbcb15da&mc_channel=shouji\">为了从前端到大前端</a></h2>\n</view><view class=\"cl-preview-section\"><p>传统的前后端合作方式是</p>\n</view><view class=\"cl-preview-section\"><ul><li>前后端分离，通过 http 接口连接</li>\n<li>前端：开发页面，调用 http 接口获取、渲染数据</li>\n<li>后端：实现 http 接口，接收和返回数据</li>\n</ul></view><view class=\"cl-preview-section\"><p>这样做的好处就是前后端职责分明，各司其职。而坏处也很明显：<strong><a href=\"https://coding.imooc.com/class/388.html?mc_marking=30fc15cce247df044d234982dbcb15da&mc_channel=shouji\">http 接口很容易混杂</a></strong>。特别是系统比较大，业务复杂，开发新功能升级旧功能，一段时间之后，你会发现 http 接口列表已经混乱不堪。</p>\n</view><view class=\"cl-preview-section\"><p>因为上述 http 接口，其实就是业务接口，而且需要前端人员，后端人员都需要参与研发和维护。参与的人和角色越多，业务越复杂，业务变化也频繁，接口混乱的程度也就越大。接口混乱了，那么前端和后端的沟通也就混乱了，弄不好还要就某个历史问题撕逼俩小时，散会后再心理暗骂半天。严重影响工作效率。</p>\n</view><view class=\"cl-preview-section\"><p>我们无法决定业务复杂度以及业务变化频率，但我们可以从系统设计上来减少参与业务的人和角色。即让后端人员更“靠后”一些，不要参与到业务中来，而更多关注数据和底层计算层面。其中前端也会更“靠后”一些，负责开发业务相关的 http 接口，即<strong>大前端</strong>模式。大前端模式还可以无缝接入 SSR ，无论是 vue React 框架还是传统的 nodejs 模板引擎都可以。</p>\n</view><view class=\"cl-preview-section\"><ul><li>大前端</li>\n<li>开发前端页面，调用接口层</li>\n<li>接口层开发业务接口 & 实现 SSR</li>\n<li>后端：关注于数据和服务，提供 http 接口或者 rpc 协议，供接口层调用</li>\n</ul></view><view class=\"cl-preview-section\"><p>大前端模式，让前端人员既开发页面，又实现业务接口，这样能最大程度的保障接口统一，也没有那么多的跨部门能沟通成本，也就提高了工作效率。而大前端最重要的环节，就是 nodejs 这一层，因为我们要用它来实现接口层。</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/388.html?mc_marking=30fc15cce247df044d234982dbcb15da&mc_channel=shouji\">总结</a></h2>\n</view><view class=\"cl-preview-section\"><p>俗话说无利不起早，公司也是无利不面试。也只有找到了面试的目的，和公司的需求，才能让自己有更明确的学习方向。</p>\n</view><view class=\"cl-preview-section\"><p>····························<br><strong>欢迎关注课程：</strong></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/388.html?mc_marking=30fc15cce247df044d234982dbcb15da&mc_channel=shouji\">《Node.js-Koa2框架生态实战－从零模拟新浪微博》</a>（限时优惠中）</p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/320.html?mc_marking=79eafdd0eb8b5dd4114bdf9b50eae184&mc_channel=shouji\">《前端晋升全栈工程师必备课程Node.js 从零开发 web server 博客项目》</a></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/190.html?mc_marking=ee24e06c9d52f85746f87c10045ffe4b&mc_channel=shouji\">《揭秘一线互联网企业 前端JavaScript高级面试 》</a></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/115.html?mc_marking=7fedde0f6ffb70e41252a92c52f6fa9b&mc_channel=shouji\">《前端JavaScript面试技巧 》</a></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/99.html?mc_marking=9b4a0b1dfc8eadaab59ce4521ecce94d&mc_channel=shouji\">《React高级实战 打造大众点评 WebApp 》</a></p>\n</view>\n\t\t\t\t\t",
                "cover": [],
                "mode": "base"
            },
            {
                "id": "289159",
                "title": "零基础-3日原神官网动移端实战集训营",
                "browse_count": 5768,
                "collection_count": 70,
                "comments_count": 9,
                "author": {
                    "id": "108955",
                    "author_name": "liuyubobobo",
                    "avatar": "//img2.sycdn.imooc.com/5347593e00010cfb01400140-160-160.jpg",
                    "status": "normal"
                },
                "classify": "精彩直播",
                "thumbs_up_count": 70,
                "create_time": "2019.07.10 14:02",
                "content": "<p>&lt;零基础-3日原神官网动移端实战集训营&gt;<br />\n火招热生，14日开讲！</p>\n<h3><a id=\"_3\"></a>课程内容</h3>\n<p>企业实战什是么样子？谢老师将带会大家从html css开完始整实现神原游戏官网动移端页面项目！包括所有交互功能，抓紧报名哦</p>\n<ol>\n<li>项目整体布局、页面成型<br />\n时间：7月14日 20:00-21:30</li>\n<li>通用布局，轮播图、前后端数据通信<br />\n时间：7月15日 20:00-21:30</li>\n<li>新闻资讯，滚动栏弹框效果<br />\n时间：7月16日 20:00-21:30</li>\n</ol>\n<h3><a id=\"_14\"></a>讲师简介</h3>\n<blockquote>\n<p>渡一教育前端讲师，精通 js 开发，对 js 的原型机制有深入研究和应用心得。精通常见的 js 开发框架与 js 库，Vue、React ，jQuery 等。</p>\n</blockquote>\n",
                "mdTxt": "<零基础-3日原神官网动移端实战集训营>\n火招热生，14日开讲！\n\n### 课程内容\n企业实战什是么样子？谢老师将带会大家从html css开完始整实现神原游戏官网动移端页面项目！包括所有交互功能，抓紧报名哦\n\n1. 项目整体布局、页面成型\n   时间：7月14日 20:00-21:30\n2. 通用布局，轮播图、前后端数据通信\n   时间：7月15日 20:00-21:30\n3. 新闻资讯，滚动栏弹框效果\n   时间：7月16日 20:00-21:30\n\n\n### 讲师简介\n> 渡一教育前端讲师，精通 js 开发，对 js 的原型机制有深入研究和应用心得。精通常见的 js 开发框架与 js 库，Vue、React ，jQuery 等。\n",
                "abstractText": "&lt;零基础-3日原神官网动移端实战集训营&gt;\n火招热生，14日开讲！\n课程内容\n企业实战什是么样子？谢老师将带会大家从html css开完始整实现神原游戏官网动移端页面项目！包括所有交互功能，抓紧报名哦\n\n项目整体布局、页面成型\n时间：7月14日 20:00-21:30\n通用布局，轮播图、前",
                "cover": [
                    "https://tva1.sinaimg.cn/large/008i3skNly1gshk4b9mikj31980t3myz.jpg",
                    "https://tva1.sinaimg.cn/large/008i3skNly1gshk4ycxzaj30k017cmzf.jpg",
                    "//img1.sycdn.imooc.com/5d25a29e00011b4e09000273.jpg",
                    "//img1.sycdn.imooc.com/5d25a2af00011c7f09000351.jpg"
                ],
                "mode": "column"
            },
            {
                "id": "26624",
                "title": "前端工作必备职场好习惯",
                "browse_count": 12530,
                "collection_count": 87,
                "comments_count": 13,
                "author": {
                    "id": "108955",
                    "author_name": "渡一教育",
                    "avatar": "https://user-center.cdn.bcebos.com/head/raw/uc.101.580c9bf.GjigisSeFdpaGDbq6d85wQ?x-bce-process=image/resize,m_lfit,w_200,h_200&autime=13",
                    "status": "normal"
                },
                "classify": "职场生活",
                "thumbs_up_count": 87,
                "create_time": "2018.04.18 16:40",
                "content": "\n![image.png](https://pc.hyfarsight.com/FtrNhuyHJ3nRMhdzwpVXtkBLFBRn)\n\n   在这个世界上，有数百万的人热衷于软件开发，他们有很多名字，如：软件工程师、程序员、开发人员、甚至是码农。无论入门时水平如何，经过一段时间学习后，他们都会非常熟悉如何用计算机语言来完成自己的工作。\n\n但是，如果你以为仅是做到熟悉计算机编程语言就可以成为优秀的程序员，未免过于天真啦。\n\n联想到此前采访过的一些技术大牛对关于如何成为优秀程序员的看法，小渡想将这个有趣的问题展开写一写，业务过关，真的就可以成为优秀程序员吗？真正优秀的程序员，需要具备哪些职场好习惯呢？\n\n无论是生活还是职场，每个人都有自己的习惯，说话做事的方法和态度都在一步一步地固定化，而个人的习惯又非常会影响到一个人的发展。好习惯越多，你的发展会顺利越多；不良的习惯越多，那么你人生路上的绊脚石就会越多。\n\n对于程序员来说，在职场中，你工作的习惯也会深深影响着你办事的效率和成绩，所以养成一些良好的工作习惯，会让你自己变得更加优秀，让你的职业发展更加顺利。\n\n\n\n### 一、构建自己的知识体系\n\n在信息爆炸的年代，碎片化的知识很多，系统学习的时间越来越少，如果没有自己的知识体系，很容易被淹没在知识的海洋中，而且难以记忆。\n\n优秀程序员推荐的做法，通过Wiki或者其他知识管理工具构建一个知识框架，大的分类可以包括软技能、架构、语言、前端、后端等，小的分类可以更细化。\n\n### 二、培养大局观\n\n程序员比较容易陷入的困境是专注于自己的一亩三分地，不关心团队的进度和业绩，也不关心软件的整体架构和其他模块。这种状态长期下去没有好处，特别是在大公司中，逐渐成长为一颗螺丝钉。\n\n优秀程序员会在工作之余，多看看其他在做什么，看看团队的整体规划，看看软件系统的架构和说明文档。对自己的工作更理解，而且知道为什么这个产品应该这样设计，为什么领导应该这样做规划，这种大局观非常有利于自己的职业生涯。\n\n![image.png](https://pc.hyfarsight.com/FjYxYQkTVUeGRjYasaH829AikD_F)\n### 三、代码规范\n\n程序员在新手时期需要培养良好的代码规范。最直接的办法，遵循公司已有的代码规范，从简单的变量命名到模块划分，有些规则可以导入到编码工具中，更多的部分需要自己体会和遵守。\n\n关于此方面的知识，最权威的书籍是《代码大全》，别误会，书名是个美丽的错误，里面不是代码集锦。对于新手来说，养成一个统一的编码风格非常重要，是基础一步。\n\n### 四、掌握多种语言\n\n程序语言总是有其最适合的领域。当你面对需要解决的问题时，你需要找到一个最适合的语言来解决这些问题。\n\n比如，如果你需要性能，可能C/C++是首选，如果你需要跨平台，可能Java是首选，如果你要写一个Web上的开发程序，那么ASP，Ajax，JSP可能会是你的选择，如果你要处理一些文本并和别的应用交互，可能Perl,Python会是最好的。\n\n所以，花一些时间去探索一下其它你并熟悉的程序语言，能让你的眼界变宽，因为你被武装得更好，你思考问题也就更为全面，这对于自己和项目都会有好的帮助。\n\n![image.png](https://pc.hyfarsight.com/FuYTNw8NwBtdFC7G_TygkPyumqld)\n### 五、理性面对不同的操作系统或技术\n\n程序员们总是有自己心目中无可比拟的技术和操作系统，然而只有一部分优秀的程序员明白不同操作系统的优势和长处和短处，这样，在系统选型的时候，才能做到真正的客观和公正，而不会让情绪影响到自己。\n\n同样，语言也是一样，有太多的程序员总是喜欢纠缠于语言的对比，优秀的程序员并不会执着于这些，而是能够理性的分析和理性的面对，从而才能客观地做出正确的选择。\n\n### 六、把你的工作变成文档\n\n这一条目当然包括了在代码中写注释，但那还仅仅不够，你还需要做得更多。\n\n有良好的注释风格的代码是一个文档的基础，他能够让你和你的团队容易的明白你的意图和想法。写下文档，并不仅仅是怕我们忘了当时的想法，而且还是一种团队的离线交流的方法，更是一种知识传递的方法。记录下你所知道的一切会是一个好的习惯。\n\n事实上，程序员群体也符合一个普遍的统计分布规律：只有少数人真的是聪明绝顶，有一些人很优秀，而大多数人至少算是能力尚可。也许他们没你有天赋，但却可以在工作中做到比你优秀，这之间的差别并不一定是编码技能。这个差异更存在于一些更基本的东西中，即个人的坏习惯。众所周知，人们在生活和工作中的确很难改掉坏习惯。\n\n也就是说，我们开发人员常常会养成一些坏习惯，同时又时时被那些麻烦的代码所打击，这些因素加在一起，最终阻碍了我们发挥自己的全部潜能。虽然有些优秀的好习惯可以帮助我们提高工作效率，但也有些不良习惯只会给我们的工作和个人生活带来麻烦。\n\n通常，我们会时刻提醒自己保持良好的工作习惯，但我们却很难察觉自己有这些坏习惯。就像生活一样，编程也没有固定不变的严格规则。所以，接下来让我们来谈谈程序员应该尽快改掉的一些编程坏习惯。\n![image.png](https://pc.hyfarsight.com/Fn5IPPNhLAdIFk_kJA4lGcfC1fIM)\n\n---\n\n一、我的代码是最好的\n\n无论是技术团队还是其他专业的团队，大家都欢迎的那种人，它的特征是：谦逊有礼、求知若渴、聪明睿智。不要随意去批评别人的代码，因为说不准什么时候就轮到你的代码放在聚光灯下被大家审视。请试着做出客观专业的观察，但不要轻易做出评判。请务必谦虚，试着向周围的人学习。\n\n永远记住，你的自负会成为你工作的障碍。\n\n如果你开始盲目地相信自己的伟大，那就意味着你的创造力开始消失。当你开始认为自己无所不知，没有什么可学的时候，你的学习自然就停止了。\n\n二、这个bug与我无关\n\n我们总是找得到借口……这就好像我们说在正常情况下我们永远不会犯错，老实说，这很难让人真正信服。\n\n一个糟糕的程序员无法做到对整个产品和bug全身心投入和承担应有的责任。相反地，当其他人出了一个bug时，他们会确保每个人都清楚地知道这个bug该由谁负责。\n\n而将责任归咎于别人到底能获得什么呢？\n\n其实根本什么都得不到。你越早承认错误，你就有越多的时间去学习和改正错误。事情真的就是这么简单！\n\n三、所谓的“完成”其实并未完成\n\n记住，“完成”的意思是，根据用户的需求完成了测试和所有相关审查。并不是你觉得“完成“了就真的完成了。\n\n一个优秀的开发人员总是渴望学习新东西。他们努力地去理解系统架构的所有部分是如何协同工作，以及它们处于何种状态。他们会去质疑特性背后的设计和思想，以找到更好的解决方案。他们明白什么是好的用户体验。\n\n那么，能概括以上所有坏习惯的一个词是什么呢？这个简单的答案是：态度。\n\n\n![image.png](https://pc.hyfarsight.com/Fmbo4LC0zWszEMVazT55ZvgJt5qE)拥有良好的态度比拥有多年的经验更重要。仅仅工作是不够的，你必须有端正的工作态度，而不是拥有正确的技能，端正的态度远比技能更为重要。\n\n其实，养成好习惯并不难，据说养成一个好习惯只需要28天。那么，你愿意挑战一下吗？",
                "cover": [
                    "https://tva1.sinaimg.cn/large/008i3skNly1gshkbdubi7j30hs0cpab8.jpg",
                    "https://tva1.sinaimg.cn/large/008i3skNly1gshkd8eft3j30hs0a0t8z.jpg",
                    "https://tva1.sinaimg.cn/large/008i3skNly1gshkdq22elj30hs0am74n.jpg",
                    "https://tva1.sinaimg.cn/large/008i3skNly1gshke2vpp8j30hs09wwel.jpg"
                ],
                "mode": "column"
            },
            {
                "id": "291507",
                "title": "培训班出身如何构建自己的知识体系？",
                "browse_count": 5077,
                "collection_count": 72,
                "comments_count": 9,
                "author": {
                    "id": "2255006",
                    "author_name": "bobby",
                    "avatar": "//img2.sycdn.imooc.com/58d9c48f0001ad0304070270-160-160.jpg",
                    "status": "normal"
                },
                "classify": "职场生活",
                "thumbs_up_count": 72,
                "create_time": "2019.08.23 11:09",
                "content": "\n\t\t\t\t\t\t<view class=\"cl-preview-section\"><h5>1. 如何看待英语和数学在编程中的重要性？</h5>\n<pre><code>先给出结论吧： 重要但是不紧急。\n英语和数学属于四象限原则中的： 重要但不紧急，同样属于这个象限的还包括基础知识：数据结构、算法、计算机网络、操作系统等\n这个象限属于很容易被忽略，大部分人的思维都是把精力放在学习哪些紧急并且重要的知识点上很容易忽略这个象限的知识点，\n可以这样一句话描述这个象限的知识点的重要性：其他知识点决定你能走多快，而这些知识点决定你能走多远。\n既然这个问题是说明英语和熟悉的重要性，那我们来说一下这两点到底重不重要：\n    1. 重要！\n    2. 学不好这两门也能学会编程并能达到很多职位的需求\n    3. 想要学好编程英语和数学相当有必要\n    4. 不一定需要首先学好英语和数学，也可以在学习编程的过程中去学习数学和英语\n\n那英语和数学在编程中的重要性体现在哪里？\n    英语：\n        1. 专业词汇\n        2. 看英语文章\n            1. 很多优秀的库和框架或者官方文档都是英文的\n            2. 大量的源码中都会用英语作为注释\n            3. 很多优秀的问题社区(stackoverflow)也是英文的\n            4. 很多时候你也需要写英文文档和英文注释\n    数学：\n        1. 算法很重要，数学思维和逻辑能力\n        2. 很多算法都会有数学公式(机器学习算法尤其突出)\n        3. 大量的问题的深入原理背后都是数学支撑的\n</code></pre>\n</view><view class=\"cl-preview-section\"><h5>2. 培训班和自学真的有区别吗？</h5>\n<pre><code>培训班和自学没有本质的区别：都是要学习！\n编程的学习有一个很重要的特性：学懂是第一位\n很多知识是属于别人给你说了你就知道了，比如很多库和框架的使用，但是灵活运用需要配合实战项目或者大量的项目反复训练。\n另一些知识属于即使讲解了很多人貌似听懂了但实际上没有弄懂，比如很多算法，算法中有一些算法不属于唯一答案，比如动态规划，需要配合大量的题目才能彻底弄懂\n还有一些很重要但是不紧急的知识点比如数据库的底层原理，很多库和框架的底层原理(elasticsearch,kafka等)，这些很多时候没人能提醒你该学或者告诉你，需要工作中去学习。\n\n其实上面可以看到我们要学习的知识非常多，这些很难在一两年时间内就搞懂。\n那接下来我们看看作为初学者，这里说到的初学者不仅仅只是转行或者刚毕业的人，对于有工作经验的人来说，比如andriod开发转python开发，转人工智能开发，这个时候也属于初学者。\n对于初学者来说更加紧急和重要的是什么呢(PPT)？\n    1. 全面的知识结构体系，比如有哪些实际的项目能锻炼人？每个方向的知识点都很多，但是哪些知识点更重要？哪些是必学的？\n    2. 具体到需要学习的知识点的时候？有哪些库或者框架是必学的？\n\n培训班的好处：\n\n    1. 快速建立知识体系结构\n    2. 少走弯路(有些弯路一旦走了可能会耽误你1、2年时间)\n    3. 培训班教的也是知识，知识不应该计较从哪里来的\n    4. 培训班集中的学习时间和氛围是自学比不了的(自学很难达到集中不间断的学习5,6个月)\n    5. 明确的目标能让学习更加高效\n    6. 好的培训机构和好的老师很重要\n    7. 对于转行的人来说，自学难度很大，培训班能够帮你快速入行\n\n培训班的缺点:\n    1. 参差不齐的质量\n    2. 明确的目的性导致没有大量的讲解重要但不紧急的基础知识\n    3. 后续的学习还需要自己\n    4. 虽然集中的时间已经很长(5个月以上)，但是相对于个人的长期成长需要学习的知识还是很短\n\n个人学习到底有低效相信对于绝大部分的人来说都是很清楚的，但是个人学习依然很重要：\n    \n    1. 长期不间断的学习\n    2. 找一个大牛(工作和生活中)模仿或者交流\n    3. 明确自己的目的(比如一个后端需要学习前端，就要集中学习，需要学习人工智能也是一样)\n    4. 自学的作用不可替代\n    5. 找到适合自己学习的方法\n    6. 有些知识点听不懂可能是别人讲不明白，多看看不同人的不同角度的讲解。 不要质疑自学的重要性和能力\n    7. 自己没有从事的行业也可以适当关注\n</code></pre>\n</view><view class=\"cl-preview-section\"><h4>3. 为什么培训班出来的就不受待见？</h4>\n<pre><code>培训班因为是短期内需要帮助找工作所以课程规划的时候更多的是框架和库的使用：\n    1. 这样本身没有问题，毕竟绝大部分公司面试还是很看重框架和库的\n    2. 底层知识缺乏，很容易导致很多人开始工作能胜任，但是随着系统越来越大，由于缺乏底层导致很多人胜任不了\n    3. 培训机构包装简历，能力和简历上的不一样\n\n无论如何，学到了就是学到了，不应该计较从哪里来，为什么很多公司强调不喜欢培训机构出来的，是为了提高招聘效率，不是否认培训机构的作用\n就像很多机构招聘喜欢通过学历筛选简历一样，毕竟很多hr面临的是一个绩效问题，所以也喜欢从高概率的人群中去筛选\n但是对于有工作经验的人来说，工作经历和项目经历更加重要，所以不用担心将来，现在需要做的就是把知识学到手。\n\n其实招聘公司不喜欢培训机构出来的和很多公司喜欢在学历上卡人是一样的原理：提高筛选效率！\n</code></pre>\n</view><view class=\"cl-preview-section\"><h5>4. 大公司和小公司更看重什么？</h5>\n<pre><code>大公司：\n    算法(只占一部分)\n    基础\n        计算机网络、操作系统、数据结构、计算机原理等\n\t框架和库的底层原理(数据库底层存储原理，es和kafka等底层存储原理)\n\t某些框架的核心流程\n    \n    原因：大公司有钱等到新人成长学习，更加关心的是遇到问题分析和解决问题的能力，因为大公司开发的项目更加注重稳定性和并发性等，这些问题需要解决会涉及到\n           分析底层，分析底层往往需要我们具备底层的基础知识，但是底层基础知识本身比较枯燥而且学习周期长，相比较而已选择更懂底层基础的就显得更加划算了，大公司有很多\n           项目都是对大型项目的维护和很多优化工作，这些对基础要求比较高\n中小公司：\n    实际项目经验\n    库和框架的熟悉程度\n    \n    中小公司面临的是快速开发和新项目的开发过程，没有那么多钱支撑很多新人的学习，要知道程序员一天的工资可不低，在钱不够的情况下还等你学习慢慢学习不现实\n    所以要求一上来就开发显得更实际了，很多中小公司新人一进公司（特别是前端）基本上当天就开始写页面，这在大公司不太可能，光是熟悉已有的代码和规范都需要不少时间\n\n大公司和小公司都很重视实际项目经验，但是侧重点可能会不一样(因人和因公司有差异)\n大公司和小公司这样筛选无可厚非，小公司面临生存，大公司需要维护和优化\n</code></pre>\n</view><view class=\"cl-preview-section\"><h4>5. 如何避免培训出来以后被歧视？</h4>\n<pre><code>1. 包装简历(初学者找工作)\n\t简历是可以包装的，比如工作年限(查学历没办法，但是相关经验年限确可以自己写)，所有公司都在意工作年限。\n\t项目经验可以包装，但是一定不要写的太多，一定要写自己熟悉的和最好是做过的\n\t有些能吹的不好说(因为有些面试官真的会吃这一套)\n2. 巩固基础(工作以后)\n\t巩固基础是一个长期的过程，想要一下子学好不现实，配合做实际工作学习效果更佳\n3. 公司最喜欢招聘的是有相关工作经验的\n4. 项目经验很重要，但是要慎重，一旦写上简历了，对方如果对你的项目经验感兴趣会追着问(你遇到哪些问题？是怎么解决的？)\n</code></pre>\n</view><view class=\"cl-preview-section\"><h4>6. 如何在职场上走的更远？</h4>\n<pre><code>1. 保持学习\n    学习是当今以及以后永远不变的一个趋势，只有保持不断的学习才会让我们不会受到年龄的限制和不会被淘汰，it技术尤其明显。低廉的升级成本会导致技术变化很快。所以我们需要保持不断的学习态度。\n2. 保持兴趣\n    长期学习最大的动力就是兴趣，所以我们需要保持兴趣。兴趣和学习在很大程度上是相互促进的,也就是说兴趣会促进学习，学习也会促进兴趣。\n3. 除了做好本职工作以外，可以提出更多的建设性意见\n    职场是非常在意产出的，比学习更重要。但是这种产出在很多时候不一定要以技术的方式表现，在中小型公司尤其突出，比如在产品设计上多提一些意见，比如在产品的框架设计上考虑远一点，比如通过技术的手段帮助营销提高效率。这些都不一定是技术产出，但是却决定了你的不可替代性，这里需要重点提醒大家就是：一定要有主动性！！！，很多事情不是主动来找你，而是你主动提出来的！！！，所以不要抱怨你没有机会。\n4. 多从产品和测试的角度考虑问题\n    产品质量和稳定性不论是对小企业还是大企业来说第一位，质量的保障最重要关卡就是测试，所以对于很多有经验的人来说会把测试看的很重要，很多有经验的程序员在开始写代码之前就会在脑子里过一下应该有哪些测试点，所以对于我们来说也是一样的。\n5. 关注架构层面的知识\n    \n    刚进公司我们把精力都放在自己负责的模块上无可厚非，但是有两三年工作经验以后我们不管是学习还是有新项目的时候我们要多从架构层面去考虑问题：\n        1. 可以使用哪些组件？是考虑稳定性？是考虑生态？是考虑性能？\n        2. 使用什么语言？优缺点是什么？\n        3. 代码和模块设计的时候是否应该考虑到扩展性?\n        4. 代码之间如何尽量降低耦合性？\n        5. 如何将服务拆分？\n        6. 如何让组员之间能够快速的沟通和替换？\n</code></pre>\n</view><view class=\"cl-preview-section\"><h5>7. 职业迷茫的时候应该怎么办？</h5>\n<pre><code>1. 会在哪些方面产生迷茫？\n    方向深入\n    换方向\n    如何技术变现\n2. 迷茫的时候改怎么办？\n\t1. 学好技术\n\t2. 关注新领域\n3. 技术可以追求一专多能\n4. 封装好自己的可重用的代码，为以后工作或者私人项目做准备\n5. 变现途径\n    \n    外包\n    长期维护一个自己的项目(开源或者商业)\n    程序员客栈\n    非it技术类\n    数据服务(分词服务，某些难的技术点)\n</code></pre>\n</view><view class=\"cl-preview-section\"><h5>8. 如何构建自己的知识体系？</h5>\n<pre><code>1. 先语言\n2. 有些基础是通用的：\n\t语法基础\n\t数据结构\n\t计算机网络\n\t操作系统原理\n\t数据库\n\t    mysql\n\t    redis\n\t    mongodb\n\t    elasticsearch\n\t    数据库优化\n\t    \n\t基础算法（排序，图，树，数组等）\n\n3. 不同的方向需要学习的差异比较大\n\t1. web开发\n\t\t框架\n\t\t高并发\n\t\t分布式(分布式锁、哈希一致性)\n\t\t各种组件(redis、kafka)\n\t\tnosql（mongodb、elasticsearch）\n\t\t图数据库（neo4j）\n\t\t数据库的原理和各种优化\n\t2. 数据分析\n\t\t机器学习\n        numpy\n        pandas\n        Matplotlib\n        \n\t3. 人工智能\n\t    深度学习\n        高等数学\n        线性代数\n        统计学\n\t4. 爬虫\n\t    计算机网络\n        http协议详细\n        ip代理原理\n        js和html等前端知识\n        scrapy等异步爬虫框架\n        selenium和动态网页\n        抓包\n        js逆向\n\t5. app开发\n\t    混合开发\n        flutter\n        react native\n        Android\n        ios\n\t6. 物联网开发\n\t7. 游戏开发\n</code></pre>\n</view><view class=\"cl-preview-section\"><h5>9. 有哪些高效的学习方法？</h5>\n<pre><code>如果说学习有一种万能的方法那都是扯淡，不同的学习方法对于不同的人来说效果不一样，不过为了学好编程，有一些常用的方法还是很有效的，大家根据自己的情况可以考虑一下：\n\n1. 算法靠刷题（leetcode， kaggle）\n\t算法最好的掌握方式就是刷题，这点和我们学习基础学科比如数学，物理等一样。我们很难通过具体的实战来概括各种算法\n2. 多做项目（架构、代码规范等）\n    做项目还是以解决问题为主，兼顾考虑如何提升代码的重用性和稳定性。如果很多项目都是重复的技术点，对于学习来说效率也比较低，但是如何每次做相同的代码都能去重构之前已有的代码对自身学习确是很好的。\n3. 关注一些技术博客\n    慕课网、微博、知乎、公众号、优秀的github开源项目都是很好的学习地，有时候你关注的某个博客不经意间推的某一篇文章能帮你大忙。也能拓宽你的视野。\n4. 写自己的博客，记录下自己的问题和解决过程。\n    自己遇到的问题以及解决方案记录下来，不论是对你以后找工作还是分享给别人以及交朋友都是非常好的，甚至可能给你带来意想不到的收获，不过要尽量原创。写博客的过程也能发现自己理解不到位的地方。\n5. 多和牛人交流\n    这一点放在最后是以为很多人可能都没有机会和大牛一起共事并有机会经常讨论问题，所以如果你遇到了，一定要紧跟着他。长期的共事你会发现你的收获可能远超过上面的方法。\n</code></pre>\n</view><view class=\"cl-preview-section\"><h5>10. 这两项最重要的技能必须要掌握！！！</h5>\n<pre><code>1. debug和看错误栈\n\n    http://coding.imooc.com/learn/questiondetail/138046.html\n\n    debug是一项非常非常重要的技能，配合debug的是错误栈。\n    对于完全不懂编程的同学来说不懂debug和看不懂错误栈可以理解。\n    对于已经学过以后还是不知道怎么debug，比如如何打断点？如何进入函数？如何跳过某一行代码？如何执行到下一个断点？如何查看变量的值真的说不过去。这是每个编程人员都应该懂得的基础。\n    我不是很建议使用print这种方式去debug的，在pycharm中直接以debug方式运行再好不过了。这点我在我的所有课程中都是尽量使用debug方式讲解的。\n    \n    错误栈对于debug简直就是标配啊，不要怕错误栈，有错误栈是好事。\n    \n    \n2. 信息搜索(google+stackoverflow)\n\n    我更加推荐使用google(上google也是程序员的一个基本，而且我发现google上python的问题比用百度多太多而且都是很对症的。)\n    之前也尝试用google和百度尝试过分别搜索java和python，发现百度搜索java更好用(可能和我搜索的问题有关),但是python一定是google比百度好用太多。\n    最好用的就是google里面搜索出来的stackoverflow上的问题。\n    \n    google搜索也是一种能力，如何去找到自己应该通过哪些关键字搜索也是一种能力。\n    \n    有很多问题不用搜索答案而是应该找到你自己的答案上的问题，比如自己的代码造成的key error， 如果我们能从错误栈中找到具体是我们自己写的某一行代码出错，这个时候你去google很有可能找不到答案，这种问题解决很简单。\n    很多异常比如不是我们自己的代码而是使用的某个库的代码中出现了这个异常那么就可以去google了。\n    \n3. 看源码（有时候文档无法兼顾所有接口的用法，这个时候需要懂看源码）\n没有必要一味的求取看源码和懂原理，先学会使用\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>···············<br><strong>欢迎关注课程：</strong></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/325.html?mc_marking=5c1e3f6cdb5438f2a12b29220c268688&mc_channel=shouji\">从零起步 系统入门Python爬虫工程师</a></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/200.html?mc_marking=a01120f2fb86e9f48ae322891c21d16b&mc_channel=shouji\">Python高级核心技术97讲</a></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/131.html?mc_marking=d031c71db291fc706002cb77ce64b4a4&mc_channel=shouji\">引爆潮流技术  Vue+Django REST framework打造生鲜电商项目</a></p>\n</view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/78.html?mc_marking=0d1ef9e4873859826694a9707dca04b4&mc_channel=shouji\">Python2.7到3.6完美升级 强力django+杀手级xadmin</a></p>\n</view>\n\t\t\t\t\t",
                "cover": [],
                "mode": "base"
            },
            {
                "id": "283364",
                "title": "小白如何入门爬虫",
                "browse_count": 6638,
                "collection_count": 42,
                "comments_count": 10,
                "author": {
                    "id": "2255006",
                    "author_name": "bobby",
                    "avatar": "//img2.sycdn.imooc.com/58d9c48f0001ad0304070270-160-160.jpg",
                    "status": "normal"
                },
                "classify": "后端开发",
                "thumbs_up_count": 42,
                "create_time": "2019.03.19 11:46",
                "content": "\n\t\t\t\t\t\t<p>在学习<a href=\"https://coding.imooc.com/class/325.html?mc_marking=5c1e3f6cdb5438f2a12b29220c268688&mc_channel=shouji\" target=\"_blank\">爬虫</a>之前我们需要明白的一个问题：</p><p><strong>    <a href=\"https://coding.imooc.com/class/325.html?mc_marking=5c1e3f6cdb5438f2a12b29220c268688&mc_channel=shouji\" target=\"_self\">爬虫能做什么？</a></strong></p><p>爬虫除了能够获取互联网的数据以外还能够帮我们完成很多繁琐的手动操作，这些操作不仅仅包括获取数据，还能够添加数据，比如：</p><p>    1. 投票<br>    2. 管理多个平台的多个账户(如各个电商平台的账号)<br>    3. 微信聊天机器人</p><p>实际的应用远不止上面这些，但是上面的应用只是除开数据本身的应用而已，数据本身的应用也是很广的：<br>    1. 机器学习语料库<br>    2. 垂直领域的服务(二手车估值)<br>    3. 聚合服务(去哪儿网,美团)<br>    4. 新闻推荐(今日头条)<br>    5. 预测和判断(医疗领域)<br>    <br>所以爬虫能做的功能非常多，也就造就了爬虫的需求也是越来越旺盛，但是很多有过后端开发的人员却觉得爬虫很简单，很多人觉得爬虫用一个库(requests)去获取一个html然后解析就行了，实际上爬虫真的这么简单吗？<br><br>   首先回答学习之前我们来问几个问题：<br>    <br>    1. 如果一个网页需要登录才能访问，怎么办?<br>    2. 对于上面的问题，很多人说模拟登录就行了，但实际上很多网站会采用各种手段去加大模拟登录的难度，如：各种验证码，登录逻辑的各种混淆和加密、参数的各种加密，这些问题都怎么解决？<br>    3. 很多网站只能手机登录怎么办？<br>    4. 很多网站为了用户体验和服务器优化，会将一个页面的各个元素采用异步加载或者js加载的方式完成？这些你有能力分析出来吗？<br>    5. 作为一个网站，各种反爬的方案也是层出不穷，当你的爬虫被反爬之后，你如何去猜测对方是怎么反爬的？<br>    6. 一个爬虫怎么发现最新的数据？如何发现一个数据是否被更新了？<br><br>如果你只是做一个简单的爬虫，比如你的爬虫就是一次性的，一次性获取某个网站的某些数据这样当然就简单了，但是你要做一个爬虫服务，你就必须要面对上面的问题，这上面还没有提到数据的提取和解析等等：<br><br></p><p>   综合上述问题接下来看一下我们要学习什么:</p><p>  <a href=\"https://coding.imooc.com/class/325.html?mc_marking=5c1e3f6cdb5438f2a12b29220c268688&mc_channel=shouji\" target=\"_blank\"><strong> 第一阶段 基础入门</strong></a>：</p><p>        1. 计算机网络的基础，包括：tcp/ip协议、socket网络编程、http协议<br>        2. 前端的基础：主要是javascript基础和ajax基础<br>        3. python的基础语法<br>        4. 数据库的基础：任何一个数据库都行，但是强烈建议学习mysql或者postgresql<br>        5. html解析的基础：beautifulsoup的使用、xpath和css选择器<br>        6. html下载的基础：urllib或者requests使用<br>        7. 数据保存的基础：如果你要使用的是关于数据库(mysql)的话可以使用pymysql、接下来使用peewee，如果你需要使用的是文档数据库(mongodb)的话,可以选择pymongo，然后使用mongoengine<br>    <br><a href=\"https://coding.imooc.com/class/325.html?mc_marking=5c1e3f6cdb5438f2a12b29220c268688&mc_channel=shouji\" target=\"_self\"><strong>    第二阶段 爬虫实战</strong></a><br>        <br>        经过前面的阶段，你只是具备了最基本的爬虫知识而已，想要真正的抓取爬虫你还需要更进一步的学习<br>        <br>        1. 模拟登录：你需要知道cookie和session登录的原理、如果需要针对性的抓取微博等你还需要知道oauth2.0的具体过程<br>        2. 动态网页分析技术: 最基本的方法是通过分析js和html等基础方法，但是很多网站会将这部分逻辑做的很复杂，所以你需要进一步学习selenium和chromedriver相关的基础<br>        3. 验证码的识别：<br>            这里包括最基本的验证码识别，比如ocr识别等，对于更复杂的验证码如果想要自己去识别的话你还得懂机器学习和图像识别技术，简单的方法就是调用第三方服务<br>        4. 对于反爬，你需要懂nginx的基本配置，你需要更一步熟悉http协议的细节<br>        5. 爬虫的开发需要配置多线程开发，所以你需要更加懂多线程的开发，这里包括了线程间通信和线程同步等基础<br>    <br> <a href=\"https://coding.imooc.com/class/325.html?mc_marking=5c1e3f6cdb5438f2a12b29220c268688&mc_channel=shouji\" target=\"_blank\"><strong>   第三阶段 爬虫监控和运维</strong></a><br>    <br>        一个爬虫上线生产环境你得监控你的爬虫吧，监控一个爬虫你最好是用页面管理吧，所以你得懂：<br>            <br>            1. linux基础，用于部署服务<br>            2. docker基础，docker部署的优势和流行相信大家都懂的<br>            3. django或者flask，因为我们需要开发页面去监控爬虫<br>    <br><a href=\"https://coding.imooc.com/class/325.html?mc_marking=5c1e3f6cdb5438f2a12b29220c268688&mc_channel=shouji\" target=\"_blank\"><strong>    第四个阶段 爬虫框架和分布式爬虫</strong></a><br>    <br>        1. 你得懂至少一门爬虫框架scrapy或者pyspider<br>        2. 懂了scrapy你还需要知道scrapy-redis知道如何去解决分布式爬虫的问题<br>        3. 你得懂分布式存储的方案：hadoop的一套解决方案<br>        4. 你得懂mongodb文档数据库<br>        5. 你得懂elasticsearch搜索引擎<br>        6. 你得懂kafaka这种分布式发布订阅消息系统<br>        7. 分布式相关的基础如分布式锁等你需要知道原理<br>    <br><a href=\"https://coding.imooc.com/class/325.html?mc_marking=5c1e3f6cdb5438f2a12b29220c268688&mc_channel=shouji\" target=\"_blank\"><strong>    第五个阶段 爬虫的应用</strong><br>        </a><br>        这个阶段就是属于应用的领域了，比如你要做人工智能，你得懂人工智能的相关知识，你如果做数据分析你得学习数据分析的基本知识，如果你是想做web服务你需要学习web开发的基础，如果你是想做搜索引擎和推荐系统你得懂相关的基础才行。</p><p>·····································</p><p><strong>欢迎关注课程：</strong></p><p><strong><a href=\"https://coding.imooc.com/class/325.html?mc_marking=5c1e3f6cdb5438f2a12b29220c268688&mc_channel=shouji\" target=\"_blank\">从零起步 系统入门Python爬虫工程师</a>（新课）</strong></p><p><a href=\"https://coding.imooc.com/class/131.html?mc_marking=d031c71db291fc706002cb77ce64b4a4&mc_channel=shouji\" target=\"_blank\"><strong>引爆潮流技术  Vue+Django REST framework打造生鲜电商项目</strong></a></p><p><strong><a href=\"https://coding.imooc.com/class/78.html?mc_marking=0d1ef9e4873859826694a9707dca04b4&mc_channel=shouji\" target=\"_blank\">Python2.7到3.6完美升级 强力django+杀手级xadmin</a></strong></p>\n\t\t\t\t\t",
                "cover": [],
                "mode": "base"
            },
            {
                "id": "295301",
                "title": "多人实时互动之各WebRTC流媒体服务器的比较",
                "browse_count": 1939,
                "collection_count": 4,
                "comments_count": 2,
                "author": {
                    "id": "4873493",
                    "author_name": "李超",
                    "avatar": "//img4.sycdn.imooc.com/5b9876c60001ffc914821482-160-160.jpg",
                    "status": "normal"
                },
                "classify": "移动开发",
                "thumbs_up_count": 4,
                "create_time": "2019.11.09 18:41",
                "content": "\n\t\t\t\t\t\t<view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/387.html?mc_marking=14d51eb28e859859dae4fe1063d81518&mc_channel=shouji\">前言</a></h2>\n</view><view class=\"cl-preview-section\"><p>随着网络基础设施的提高，音视频实时通信越来越成为人们日常生活和工作中必不可少的需求。2011年 WebRTC的出现，则更加速了这种需求变为现实的可能性。</p>\n</view><view class=\"cl-preview-section\"><p>熟悉 <a href=\"https://coding.imooc.com/class/387.html?mc_marking=14d51eb28e859859dae4fe1063d81518&mc_channel=shouji\">WebRTC</a> 的同学应该都知道，WebRTC规范只定义了实时通信中客户端的行为，而没有规范服务端（包括哪些信令、数据如何流转）的行为。所以，你可以使用WebRTC库方便的实现 1:1 实时通信，但对于多人实时互动，光依靠 WebRTC库显然就无法完成要求了。</p>\n</view><view class=\"cl-preview-section\"><p>那我们该如何实现多人实时互动通信呢？</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/387.html?mc_marking=14d51eb28e859859dae4fe1063d81518&mc_channel=shouji\">WebRTC 流媒体服务器</a></h2>\n</view><view class=\"cl-preview-section\"><p>要想实现多人的实时互动，如音视频会议、在线教育这类产品，我们必须使用 WebRTC + WebRTC流媒体服务器这种方案。</p>\n</view><view class=\"cl-preview-section\"><p>目前有很多比较有名的开源流媒体服务器，如 Janus、Medooze、Mediasoup、Licode(OWT)、Jitsi等等。这些流媒体服务器各有优缺点，下面我就对这几种流媒体服务器作下简要的介绍与比较。</p>\n</view><view class=\"cl-preview-section\"><p>通过本文，你将知道各 WebRTC 流媒体服务器的优缺点，并依俱它们的优缺点选择出更适合你的那款WebRTC流媒体服务器。</p>\n</view><view class=\"cl-preview-section\"><h3>Mediasoup</h3>\n</view><view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"//img1.sycdn.imooc.com/5dc698450001a9f712760906.png\" data-original=\"//img1.sycdn.imooc.com/5dc698450001a9f712760906.png\" alt=\"Mediasoup架构图\" style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>上图是Mediasoup整体架构图，通过该图我们可以知道 Mediasoup 流媒体服务器是由 Nodejs 和 Mediasoup(C++) 两部分组成。</p>\n</view><view class=\"cl-preview-section\"><ul><li>Nodejs，负责 Mediasoup 的信令接收与业务管理。如创建/消毁房间，创建/关闭生产者，创建/关闭消费者等。</li>\n<li>Mediasoup(C++)，这是一个单独的程序，但该程序无法直接启动。因为它在内部会判断是否是 Nodejs 将它启动起来了。只有在Nodejs 的 Mediasoup 管理模块加载之后，再将 Mediasoup(C++)启动起来，这样它才能正常工作。</li>\n</ul></view><view class=\"cl-preview-section\"><p>在众多的 WebRTC 流媒体服务器中，Mediasoup 可以说是性能最优秀的WebRTC流媒体服务器。它使用 C++ 作为开发语言，底层使用 libuv 处理 I/O 事件。</p>\n</view><view class=\"cl-preview-section\"><p>有很多人对 Nodejs 比较诟病，认为 Nodejs 提拱不了高性能的流媒体服务器。实际上，如果按照传输的 Nodejs 应用开发出的流媒体服务器肯定是不能胜任这项工作的。但对于 Mediasoup 来讲，它只不过使用 Nodejs 做 信令处理 及 业务的管理 工作，所以它的负担并不重。对性能要求高的是媒体数据流的转发工作，而这部分工作是由 Mediasoup(C++)部分实现的。Nodejs 与 Mediasoup之间通过管道进行通信。</p>\n</view><view class=\"cl-preview-section\"><p>严格意义上来说，Mediasoup是单进程的。但你不要以为这就影响了它的性能。实际上，它是使用单进程的方式将服务器上CPU某个 <code>核</code> 充分利用好，然后在业务层控制进程的个数。比如说你的服务器是个 8 核的CPU，那么在业务层你就该启动 8 个Mediasoup进程。通过这种方式来达到对 CPU 的充分利用。</p>\n</view><view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"//img1.sycdn.imooc.com/5dc698e400014cb711420915.png\" data-original=\"//img1.sycdn.imooc.com/5dc698e400014cb711420915.png\" alt=\"图片描述\" style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>Mediasoup中的每个进程称为一个 Worker, 你也可以把它理解为一个<code>节点</code>，在每个 Worker 中可以有多个 Router。对于 Router，你站在不同的解度可以有不同的理解。如果你占在应用层的角度，你可以把它理解为一个房间；如果你站在数据流转的角度，可以把它理解为一个路由器，数据通过 <code>路由器</code> 转发给目标用户。</p>\n</view><view class=\"cl-preview-section\"><p>想了解更多Mediasoup的细节，可以观看我的视频课 <a href=\"https://coding.imooc.com/class/387.html\">《百万级高并发WebRTC流媒体服务器设计与开发》</a>，在这个视频中我对 Mediasoup 源码做了深入剖析。</p>\n</view><view class=\"cl-preview-section\"><h3>Janus</h3>\n</view><view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"//img1.sycdn.imooc.com/5dc6990d00013b0b16260978.png\" data-original=\"//img1.sycdn.imooc.com/5dc6990d00013b0b16260978.png\" alt=\"图片描述\" style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>上面这张图是 Janus 的整体架构图。在这张图中我们可以看到， 从大的方面说 Janus 由 Janus CORE、Janus Plugin 以及信令接口三部分组成。</p>\n</view><view class=\"cl-preview-section\"><ul><li>信令接口，Janus 支持的信令协议比较多，如 HTTP、WebSocket、RabbitMQ 等。这些信令协议使得 Janus 具有非常好的接入性。因为很多公司喜欢各种不同的协议，如有的喜欢 websocket，有的喜欢http，proto等。因此 Janus 在信令接入方面具有很大的优势。</li>\n<li>Janus Plugin，Janus 的业务管理是按照 Plugin 的方式管理的，因此你可以在Janus中根据自己的需要实现自己的业务插件。实际上，对于一般性的需求 Janus 已经相关的插件。如：\n<ul><li>VideoRoom，用于多人音视频互动，像音视频会议，在线教育都可以通过该插件来实现。</li>\n<li>VideoCall，用于 1:1 的音视频通信。</li>\n<li>SIP，用于与传统电话设备对接。</li>\n<li>Streaming，用于广播，也就是我们通常所说的一人共享，多人观看的直播模式。</li>\n<li>TextRoom，它是一个聊天室，通过它可以进行文本聊天。</li>\n<li>RecordPlay，用于录制和回放。</li>\n</ul></li>\n<li>Janus Core 是Janus的核心，其作用是处理流的转发，各种协议的接入。以浏览器为例，要想让浏览器接入到 WebRTC 流媒体服务器上，那流媒体服务器必须要支持 STUN、DTLS、SRTP、ICE 等协议。而 Janus Core 就是专门做这事儿的。</li>\n</ul></view><view class=\"cl-preview-section\"><p><a href=\"https://coding.imooc.com/class/387.html?mc_marking=14d51eb28e859859dae4fe1063d81518&mc_channel=shouji\">Janus</a> 是由 C语言开发的，因此它的性能非常优秀。要说不足的话，janus 底层没有使用 epoll 这类异步I/O事件处理机制，这应该说是它的一大缺陷；另外，Janus还使用 glib 库，由于 glib 库对于国内的很多开发同学来说用的比较少，所以会有一定的学习成本。</p>\n</view><view class=\"cl-preview-section\"><p>整体上看，Janus采用了插件的架构设计方案。这种方案非常适合于有多种业务模型或业务经常发生变化的公司或项目。另外 Janus 支持多种消息传输协议，这对于开发人员来说具有极大的吸引力。</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/387.html?mc_marking=14d51eb28e859859dae4fe1063d81518&mc_channel=shouji\">Medooze</a></h2>\n</view><view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"//img1.sycdn.imooc.com/5dc699260001242a12760906.png\" data-original=\"//img1.sycdn.imooc.com/5dc699260001242a12760906.png\" alt=\"图片描述\" style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>Medooze 的整体架构与 Mediasoup 类似，不过它的信令处理、业务管理以及媒体数据的转发功能都是放在 Nodejs下进行统一管理的。实际上，这样的管理方式也不会对性能造成什么影响，因为重的媒体流的转发工作仍然是使用的 C++ 在 Nodejs 底层实现的。</p>\n</view><view class=\"cl-preview-section\"><p>Medooze 的业务功能要比 Mediasoup 强大，像服务端录制、推流这些 Mediasoup 没有的功能它都支持。但它性能没有 Mediasoup 做的极致，在Medooze的底层使用的poll来处理I/O事件，poll与epoll性能相差距大。除此之外，Medooze的业务逻辑也没有Mediasoup简洁；另外与 Janus 相比，它的业务管理不如 Janus 灵活，Janus 的插件管理方式显然要优于 Medooze 和 mediasoup。</p>\n</view><view class=\"cl-preview-section\"><p>但总的来说，Medooze还是一款非常不错的 WebRTC 流媒体服务器。虽然有一些小的暇疵，但还是非常不错的一款流媒体服务器。</p>\n</view><view class=\"cl-preview-section\"><p>想了解更多 Medooze 细节的同学可以看我的专栏 <a href=\"https://time.geekbang.org/column/article/136000\">《从0打造音视频直播系统》</a>。</p>\n</view><view class=\"cl-preview-section\"><h2><a href=\"https://coding.imooc.com/class/387.html?mc_marking=14d51eb28e859859dae4fe1063d81518&mc_channel=shouji\">小结</a></h2>\n</view><view class=\"cl-preview-section\"><p>通过上面的描述，我想你应该对目前主流的 WebRTC 流媒体服务器有了一个大体的了解。所以在选型上你可以按照自己团队的能力进行评估到底该用那个流媒体服务器。</p>\n</view><view class=\"cl-preview-section\"><p>如果你团队能力比较强，可以做底层开发，那么建议你使用 <a href=\"https://coding.imooc.com/class/387.html?mc_marking=14d51eb28e859859dae4fe1063d81518&mc_channel=shouji\">Mediasoup</a>。因为 Mediasoup 不关心应用层，它关注的是底层数据如何高效的流转，代码简洁、高效，性能极佳。</p>\n</view><view class=\"cl-preview-section\"><p>如果你们要做的业务种类比较多，变化比较快，那建议你选择使用 Janus 作为流媒体服务器。将你的业务做成一个插件放到 Janus上很快就能实现你们的业务需求。</p>\n</view><view class=\"cl-preview-section\"><p>如果你们的业务变化不大，除了追求性能外，还需要录制、推流之类的功能，那么你可以选择使用Medooze，它可以很好的满足你们的需求。</p>\n</view><view class=\"cl-preview-section\"><p>当然，除了上面我介绍到的几款比较流行的 WebRTC 流媒体服务器外，还有一些其它的流媒体服务器，如 Licode、OWT、Jitsi等也可以选择。</p>\n</view><view class=\"cl-preview-section\"><p>Licode 之所以名气比较大，是因为它推出的时间比较早。而 OWT 是 Licode 的一个变种，它在 Licode上实现了 SFU 功能。看一下 Licode 代码你就会发现，Licode 实现了一套完整的音视频会议系统，对于这样一套系统它的实现非常复杂。如果你的团队没有音视频方面的开发人才的话，可以考虑Licode，将它搭建出来之后就可以直接使用了。但如果你有业务变化想修改它就太麻烦了。</p>\n</view><view class=\"cl-preview-section\"><p>Jitsi 上层是使用 Java 语言开发的，但底层也是使用的 C/C++ 语言。它通过 JNI 来实现Java与 C/C++之间的通信。在 2018 年有机构做过一次性能评测，当时 Jitsi 表现比较差强人意，不知现在是否已经有了改进。</p>\n</view><view class=\"cl-preview-section\"><p>以上就是对几款 WebRTC流媒体服务器的比较，希望本文可以帮助你解决WebRTC流媒体服务器的选择问题。</p>\n</view><view class=\"cl-preview-section\"><h2>参考</h2>\n</view><view class=\"cl-preview-section\"><ul><li><a href=\"https://coding.imooc.com/class/387.html?mc_marking=14d51eb28e859859dae4fe1063d81518&mc_channel=shouji\">《百万级高并发WebRTC流媒体服务器设计与开发》</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/136000\">《从0打造音视频直播系统》</a>。</li>\n</ul></view>\n\t\t\t\t\t",
                "cover": [
                    "//img1.sycdn.imooc.com/5dc698450001a9f712760906.png",
                    "//img1.sycdn.imooc.com/5dc698e400014cb711420915.png",
                    "//img1.sycdn.imooc.com/5dc6990d00013b0b16260978.png",
                    "//img1.sycdn.imooc.com/5dc699260001242a12760906.png"
                ],
                "mode": "column"
            },
            {
                "id": "286567",
                "title": "iOS 端实现1对1音视频实时通话",
                "browse_count": 2030,
                "collection_count": 4,
                "comments_count": 1,
                "author": {
                    "id": "4873493",
                    "author_name": "李超",
                    "avatar": "//img4.sycdn.imooc.com/5b9876c60001ffc914821482-160-160.jpg",
                    "status": "normal"
                },
                "classify": "移动开发",
                "thumbs_up_count": 4,
                "create_time": "2019.05.11 22:48",
                "content": "\n\t\t\t\t\t\t<view class=\"cl-preview-section\"><h2>前言</h2>\n</view><view class=\"cl-preview-section\"><p>之前，我已经写过 <a href=\"http://www.imooc.com/article/285511\">Android 端实现1对1音视频实时通话</a> 的文章。在那篇文章中，我向大家介绍了在 Android 端是如何使用 WebRTC 进行音视频通话的。今天，我们再来看看 iOS 端1对1音视频实时通话的具体实现。</p>\n</view><view class=\"cl-preview-section\"><p>iOS 端的实现逻辑与 Android 端基本相同，最大的区别可能是语言方面的差异啦！所以，下面我基本上还是按照介绍 Android 端一样的过程来介绍 iOS 端的实现。具体步骤如下：</p>\n</view><view class=\"cl-preview-section\"><ul><li>权限申请</li>\n<li>引入 WebRTC 库</li>\n<li>采集并显示本地视频</li>\n<li>信令驱动</li>\n<li>创建音视频数据通道</li>\n<li>媒体协商</li>\n<li>渲染远端视频</li>\n</ul></view><view class=\"cl-preview-section\"><p>通过上面几个小节，全面介绍如何在iOS端实现1对1实时通话。</p>\n</view><view class=\"cl-preview-section\"><h2>申请权限</h2>\n</view><view class=\"cl-preview-section\"><p>首先，我们来看一下 iOS 端是如何获取访问音视频设备权限的。相比 Android 端而言，iOS端获取相关权限要容易很多。其步骤如下：</p>\n</view><view class=\"cl-preview-section\"><ul><li>打开项目，点击左侧目录中的项目。</li>\n<li>在左侧目录找到 <strong>info.plist</strong>，并将其打开。</li>\n<li>点击 <strong>右侧</strong> 看到 “+” 号的地方。</li>\n<li>添加 Camera 和 Microphone 访问权限。</li>\n</ul></view><view class=\"cl-preview-section\"><p>下面这张图更清晰的展现了申请权限的步骤：</p>\n</view><view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"https://upload-images.jianshu.io/upload_images/5956443-16123c09ff144469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" data-original=\"https://upload-images.jianshu.io/upload_images/5956443-16123c09ff144469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640\" alt=\"iOS申请权限\" style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>通过以上步骤，我们就将访问音视频设备的权限申请好了。申请完权限后，下面我们来看一下iOS端如何引入 WebRTC 库。</p>\n</view><view class=\"cl-preview-section\"><h2>引入WebRTC库</h2>\n</view><view class=\"cl-preview-section\"><p>在iOS端引入 WebRTC 库有两种方式：</p>\n</view><view class=\"cl-preview-section\"><ul><li>第一种，是通过 WebRTC 源码编译出 WebRTC 库，然后在项目中手动引入它；</li>\n<li>第二种方式，是 WebRTC 官方会定期发布编译好的 WebRTC 库，我们可以使用 Pod 方式进行安装。</li>\n</ul></view><view class=\"cl-preview-section\"><p>在本项目中，我们使用第二种方式。</p>\n</view><view class=\"cl-preview-section\"><p>使用第二种方式引入 WebRTC 库非常简单，我们只需要写个 <strong>Podfile</strong> 文件就可以了。在 <strong>Podfile</strong> 中可以指定下载 WebRTC 库的地址，以及我们要安装的库的名子。</p>\n</view><view class=\"cl-preview-section\"><p><strong>Podfile</strong> 文件的具体格式如下:</p>\n</view><view class=\"cl-preview-section\"><pre><code>source 'https://github.com/CocoaPods/Specs.git'\n  \nplatform :ios,'11.0'\n\ntarget 'WebRTC4iOS2' do\n\npod 'GoogleWebRTC'\n\nend\n\n</code></pre>\n</view><view class=\"cl-preview-section\"><ul><li>source，指定了库文件从哪里下载</li>\n<li>platform，指定了使用的平台及平台版本</li>\n<li>target，指定项目的名子</li>\n<li>pod，指定要安装的库</li>\n</ul></view><view class=\"cl-preview-section\"><p>有了 Podfile 之后，在当前目录下执行 <code>pod install</code> 命令，这样 Pod 工具就可以将 WebRTC 库从源上来载下来。</p>\n</view><view class=\"cl-preview-section\"><p>在执行 <code>pod install</code> 之后，它除了下载库文件之外，会为我们产生一个新的工作空间文件，即**{project}.xcworkspace**。在该文件里，会同时加载项目文件及刚才安装好的 Pod 依赖库，并使两者建立好关联。</p>\n</view><view class=\"cl-preview-section\"><p>这样，WebRTC库就算引入成功了。下面就可以开始写我们自己的代码了。</p>\n</view><view class=\"cl-preview-section\"><h2>获取本地视频</h2>\n</view><view class=\"cl-preview-section\"><p>WebRTC 库引入成功之后，我们就可以开始真正的 WebRTC 之旅了。下面，我们来看一下如何获取本地视频并将其展示出来。</p>\n</view><view class=\"cl-preview-section\"><p>在获取视频之前，我们首先要选择使用哪个视频设备采集数据。在WebRTC中，我们可以通过<strong>RTCCameraVideoCapture</strong> 类获取所有的视频设备。如下所示：</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-objc\"><code class=\"prism language-objc\">NSArray<AVCaptureDevice*>* devices = [RTCCameraVideoCapture captureDevices];\nAVCaptureDevice* device = devices[0];\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>通过上面两行代码，我们就拿到了视频设备中的第一个设备。简单吧！</p>\n</view><view class=\"cl-preview-section\"><p>当然，光有设备还不行。我们还要清楚从设备中采集的数据放到哪里了，这样我们才能将其展示出来。</p>\n</view><view class=\"cl-preview-section\"><p>WebRTC 为我们提供了一个专门的类，即 <strong>RTCVideoSource</strong>。它有两层含义：</p>\n</view><view class=\"cl-preview-section\"><ul><li>一是表明它是一个视频<strong>源</strong>。当我们要展示视频的时候，就从这里获取数据；</li>\n<li>另一方面，它也是一个<strong>终点</strong>。即，当我们从视频设备采集到视频数据时，要交给它暂存起来。</li>\n</ul></view><view class=\"cl-preview-section\"><p>除此之外，为了能更方便的控制视频设备，WebRTC 提供了一个专门用于操作设备的类，即 <strong>RTCCameraVideoCapture</strong>。通过它，我们就可以自如的控制视频设备了。</p>\n</view><view class=\"cl-preview-section\"><p>通过上面介绍的两个类，以及前面介绍的 <strong>AVCaptureDevice</strong>，我们就可以轻松的将视频数据采集出来了。下面我们就来具体看一下代码吧！</p>\n</view><view class=\"cl-preview-section\"><p>在该代码中，首先将 <strong>RTCVideoSource</strong> 与 <strong>RTCCameraVideoCapture</strong> 进行绑定，然后再开启设备，这样视频数据就源源不断的被采集到 <strong>RTCVideoSource</strong> 中了。</p>\n</view><view class=\"cl-preview-section\"><pre class=\"language-objectc\"><code class=\"prism language-objectc\">...\n\nRTCVideoSource* videoSource = [factory videoSource];\ncapture = [[RTCCameraVideoCapturer alloc] initWithDelegate:videoSource];\n\n...\n\n[capture startCaptureWithDevice:device\n                             format:format\n                                fps:fps];\n...\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>通过上面的几行代码就可以从摄像头捕获视频数据了。</p>\n</view><view class=\"cl-preview-section\"><p>这里有一点需要特别强调一下，就是 <strong>factory</strong> 对象。在 WebRTC Native 层，<strong>factory</strong> 可以说是 <strong>“万物的根源”</strong>，像 RTCVideoSource、RTCVideoTrack、RTCPeerConnection 这些类型的对象，都需要通过 <strong>factory</strong> 来创建。 那么，<strong>factory</strong> 对象又是如何创建出来的呢？</p>\n</view><view class=\"cl-preview-section\"><p>通过下面的代码你就可以一知究竟了：</p>\n</view><view class=\"cl-preview-section\"><pre><code>...\n\n[RTCPeerConnectionFactory initialize];\n    \n//如果点对点工厂为空\nif (!factory)\n{\n    RTCDefaultVideoDecoderFactory* decoderFactory = [[RTCDefaultVideoDecoderFactory alloc] init];\n    RTCDefaultVideoEncoderFactory* encoderFactory = [[RTCDefaultVideoEncoderFactory alloc] init];\n    NSArray* codecs = [encoderFactory supportedCodecs];\n    [encoderFactory setPreferredCodec:codecs[2]];\n    \n    factory = [[RTCPeerConnectionFactory alloc] initWithEncoderFactory: encoderFactory\n                                                        decoderFactory: decoderFactory];\n\n}\n...\n\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>在上面代码中，</p>\n</view><view class=\"cl-preview-section\"><ul><li>首先要调用 RTCPeerConnectionFactory 类的 initialize 方法进行初始化；</li>\n<li>然后创建 <strong>factory</strong> 对象。需要注意的是，在创建 <strong>factory</strong> 对象时，传入了两个参数：一个是默认的编码器；一个是默认的解码器。我们可以通过修改这两个参数来达到使用不同编解码器的目的。</li>\n</ul></view><view class=\"cl-preview-section\"><p>有了 <strong>factory</strong> 对象后，我们就可以开始创建其它对象了。那么，紧接下来的问题就是如何将采集到的视频展示出来了。</p>\n</view><view class=\"cl-preview-section\"><p>在iOS端展示本地视频与Android端还是有很大区别的，这主要是由于不同系统底层实现方式不一样。为了更高效的展示本地视频，它们采用了不同的方式。</p>\n</view><view class=\"cl-preview-section\"><p>在iOS端展示本地视频其实非常的简单，只需要在调用 capture 的 <strong>startCaptureWithDevice</strong> 方法之前执行下面的语句就好了：</p>\n</view><view class=\"cl-preview-section\"><pre><code>self.localVideoView.captureSession = capture.captureSession;\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>当然，在iOS页面初始化的时候，一定要记得定义 <strong>localVideoView</strong> 哟，其类型为 <strong>RTCCameraPreviewView</strong>！</p>\n</view><view class=\"cl-preview-section\"><p>通过上面的步骤，我们就可以看到视频设备采集到的视频图像了。</p>\n</view><view class=\"cl-preview-section\"><h2>信令驱动</h2>\n</view><view class=\"cl-preview-section\"><p>上面我们介绍了iOS端权限的申请，WebRTC库的引入，以及本地视频的采集与展示，这些功能实现起来都很简单。但接下来我们要介绍的信令就要复杂一些了。</p>\n</view><view class=\"cl-preview-section\"><p>在任何系统中，都可以说信令是系统的灵魂。例如，由谁来发起呼叫；媒体协商时，什么时间发哪种 <strong>SDP</strong> 都是由信令控制的。</p>\n</view><view class=\"cl-preview-section\"><p>对于本项目来说，它的信令相对还是比较简单，它包括下面几种信令：</p>\n</view><view class=\"cl-preview-section\"><p><strong>客户端命令</strong></p>\n</view><view class=\"cl-preview-section\"><ul><li>join，用户加入房间</li>\n<li>leave，用户离开房间</li>\n<li>message，端到端命令（offer、answer、candidate）</li>\n</ul></view><view class=\"cl-preview-section\"><p><strong>服务端命令</strong></p>\n</view><view class=\"cl-preview-section\"><ul><li>joined，用户已加入</li>\n<li>leaved，用户已离开</li>\n<li>other_joined，其它用户已加入</li>\n<li>bye，其它用户已离开</li>\n<li>full，房间已满</li>\n</ul></view><view class=\"cl-preview-section\"><p>这些信令之间是怎样一种关系？在什么情况下该发送怎样的信令呢？要回答这个问题我们就要看一下信令状态机了。</p>\n</view><view class=\"cl-preview-section\"><h3>信令状态机</h3>\n</view><view class=\"cl-preview-section\"><p>在 iOS 端的信令与我们之前介绍的 js端 和 Android 端一样，会通过一个信令状态机来管理。在不同的状态下，需要发不同的信令。同样的，当收到服务端，或对端的信令后，状态会随之发生改变。下面我们来看一下这个状态的变化图吧：</p>\n</view><view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"https://upload-images.jianshu.io/upload_images/5956443-2f71ce4133ec8484.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" data-original=\"https://upload-images.jianshu.io/upload_images/5956443-2f71ce4133ec8484.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"信令状态机\" style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>在初始时，客户端处于 init/leaved 状态。</p>\n</view><view class=\"cl-preview-section\"><ul><li>在 init/leaved 状态下，用户只能发送 <strong>join</strong> 消息。服务端收到 <strong>join</strong> 消息后，会返回 <strong>joined</strong> 消息。此时，客户端会更新为 <strong>joined</strong> 状态。</li>\n<li>在 <strong>joined</strong> 状态下，客户端有多种选择，收到不同的消息会切到不同的状态:\n<ul><li>如果用户离开房间，那客户端又回到了初始状态，即 init/leaved 状态。</li>\n<li>如果客户端收到 <strong>second user join</strong> 消息，则切换到 <strong>join_conn</strong> 状态。在这种状态下，两个用户就可以进行通话了。</li>\n<li>如果客户端收到 <strong>second user leave</strong> 消息，则切换到 <strong>join_unbind</strong> 状态。其实 <strong>join_unbind</strong> 状态与 <strong>joined</strong> 状态基本是一致的。</li>\n</ul></li>\n<li>如果客户端处于 <strong>join_conn</strong> 状态，当它收到 <strong>second user leave</strong> 消息时，也会转成 <strong>joined_unbind</strong> 状态。</li>\n<li>如果客户端是 <strong>joined_unbind</strong> 状态，当它收到 <strong>second user join</strong> 消息时，会切到 <strong>join_conn</strong> 状态。</li>\n</ul></view><view class=\"cl-preview-section\"><p>通过上面的状态图，我们就非常清楚的知道了在什么状态下应该发什么信令；或者说，发什么样的信令，状态会发生怎样的变化了。</p>\n</view><view class=\"cl-preview-section\"><h3>引入 <a href=\"http://socket.io\">socket.io</a> 库</h3>\n</view><view class=\"cl-preview-section\"><p>看过我之前文章的同学应该都清楚，无论是在  js端，还是在 Android 端的实时通话中，我一直使用 socket.io库作为信令的基础库。之所以选择 <a href=\"http://socket.io\">socket.io</a> 是基于以下原因：</p>\n</view><view class=\"cl-preview-section\"><ul><li>一方面是由于它支持跨平台，这样在各个平台上我们都可以保持相同的逻辑；</li>\n<li>另一方面，<a href=\"http://socket.io\">socket.io</a> 使用简单，功能又非常强大；</li>\n</ul></view><view class=\"cl-preview-section\"><p>不过，在 iOS 端的 <a href=\"http://socket.io\">socket.io</a> 是用 <strong>swift</strong> 语言实现的，而我们的1对1系统则是用 Object-C 实现的。那么，就带来一个问题，在 OC (Object-C) 里是否可以直接使用 swift 编写的库呢？</p>\n</view><view class=\"cl-preview-section\"><p>答案是肯定的。我们只需要在 Podfile 中 增加 <code>use_frameworks!</code> 指令即可。 所以，我们的 Podfile 现在应该变成这个样子：</p>\n</view><view class=\"cl-preview-section\"><pre><code>source 'https://github.com/CocoaPods/Specs.git'\n  \nplatform :ios,'11.0'\n\nuse_frameworks!\n\ntarget 'WebRTC4iOS2' do\n\npod 'Socket.IO-Client-Swift', '~> 13.3.0'\npod 'GoogleWebRTC'\n\nend\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>上面 Podfile 中，每行的含义大家应该都很清楚了，我这里就不做过多讲解了。</p>\n</view><view class=\"cl-preview-section\"><h2>信令的使用</h2>\n</view><view class=\"cl-preview-section\"><p><strong><a href=\"http://socket.io\">socket.io</a></strong> 库引入成功后，下面我们来看一下何使用 <a href=\"http://socket.io\">socket.io</a>。在 iOS 下，使用 <a href=\"http://socket.io\">socket.io</a> 分为三步：</p>\n</view><view class=\"cl-preview-section\"><ul><li>通过 url 获取 socket。有了 socket 之后我们就可建立与服务器的连接了。</li>\n<li>注册侦听的消息，并为每个侦听的消息绑定一个处理函数。当收到服务器的消息后，随之会触发绑定的函数。</li>\n<li>通过 socket 建立连接。</li>\n<li>发送消息。</li>\n</ul></view><view class=\"cl-preview-section\"><p>下我们我们就逐一的看它们是如何实现的吧！</p>\n</view><view class=\"cl-preview-section\"><p><strong>获取 socket</strong></p>\n</view><view class=\"cl-preview-section\"><p>在 iOS 中获取 socket 其实很简单，我们来看一下代码：</p>\n</view><view class=\"cl-preview-section\"><pre><code>NSURL* url = [[NSURL alloc] initWithString:addr];\nmanager = [[SocketManager alloc] initWithSocketURL:url\n                                            config:@{\n                                            \t@\"log\": @YES,\n    \t\t\t\t\t\t\t\t\t\t\t@\"forcePolling\":@YES,\n                                                @\"forceWebsockets\":@YES\n                                                }];\nsocket = manager.defaultSocket;\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>没错，通过这三行代码就可以了。至于为什么这么写我就不解释了，大家记下来就好了。这是 socket.io的固定格式。</p>\n</view><view class=\"cl-preview-section\"><p><strong>注册侦听消息</strong></p>\n</view><view class=\"cl-preview-section\"><p>使用 <a href=\"http://socket.io\">socket.io</a> 注册一个侦听消息也非常容易，如下所示：</p>\n</view><view class=\"cl-preview-section\"><pre><code>[socket on:@\"joined\" callback:^(NSArray * data, SocketAckEmitter * ack) {\n    NSString* room = [data objectAtIndex:0];\n    \n    NSLog(@\"joined room(%@)\", room);\n    \n    [self.delegate joined:room];\n    \n}];\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>上面就是注册一个 <strong>joined</strong> 消息，并给它绑定一个匿名的处理函数。如果带来的消息还有参数的话，我们可以从 data 这个数组中获取到。</p>\n</view><view class=\"cl-preview-section\"><p>同样的道理，如果我们想注册一个新的侦听消息，可以按着上面的格式，只需将 <strong>joined</strong> 替换一下就可以了。</p>\n</view><view class=\"cl-preview-section\"><p><strong>建立连接</strong><br>\n这个就更简单了，下接上代码了：</p>\n</view><view class=\"cl-preview-section\"><pre><code>[socket connect];\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>没错，只这一句连接就建好了哈！</p>\n</view><view class=\"cl-preview-section\"><p><strong>发送消息</strong><br>\n接下来，让我们看一下如何使用 <a href=\"http://socket.io\">socket.io</a> 发送消息。</p>\n</view><view class=\"cl-preview-section\"><pre><code>...\nif(socket.status == SocketIOStatusConnected){\n    [socket emit:@\"join\" with:@[room]];\n}\n...\n</code></pre>\n</view><view class=\"cl-preview-section\"><p><a href=\"http://socket.io\">socket.io</a> 使用 <strong>emit</strong> 方法发送消息。它可以带一些参数，这些参数都被放在一个数据里。在上面的代码中，首先要判断socket是否已经处理连接状态，只有处于连接状态时，消息才能被真正发送出去。</p>\n</view><view class=\"cl-preview-section\"><p>以上就是 <a href=\"http://socket.io\">socket.io</a> 的使用，是不是非常的简单？</p>\n</view><view class=\"cl-preview-section\"><h2>创建 RTCPeerConnection</h2>\n</view><view class=\"cl-preview-section\"><p>信令系统建立好后，后面的逻辑都是围绕着信令系统建立起来的。<strong>RTCPeerConnection</strong> 对象的建立也不例外。</p>\n</view><view class=\"cl-preview-section\"><p>在客户端，用户要想与远端通话，首先要发送 <strong>join</strong> 消息，也就是要先进入房间。此时，如果服务器判定用户是合法的，则会给客户端回 <strong>joined</strong> 消息。</p>\n</view><view class=\"cl-preview-section\"><p>客户端收到 <strong>joined</strong> 消息后，就要创建 RTCPeerConnection 了，也就是要建立一条与远端通话的音视频数据传输通道。</p>\n</view><view class=\"cl-preview-section\"><p>下面，我们就来看一下 RTCPeerConnection 是如何建立的：</p>\n</view><view class=\"cl-preview-section\"><pre><code>...\n\nif (!ICEServers) {\n    ICEServers = [NSMutableArray array];\n    [ICEServers addObject:[self defaultSTUNServer]];\n}\n\nRTCConfiguration* configuration = [[RTCConfiguration alloc] init];\n[configuration setIceServers:ICEServers];\nRTCPeerConnection* conn = [factory\n                                 peerConnectionWithConfiguration:configuration\n                                                     constraints:[self defaultPeerConnContraints]\n                                                        delegate:self];\n\n...\n\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>对于 iOS 的 <strong>RTCPeerConnection</strong> 对象有三个参数：</p>\n</view><view class=\"cl-preview-section\"><ul><li>第一个，是 RTCConfiguration 类型的对象，该对象中最重要的一个字段是 <strong>iceservers</strong>。它里边存放了 stun/turn 服务器地址。其主要作用是用于NAT穿越。对于 NAT 穿越的知识大家可以看 <a href=\"https://coding.imooc.com/class/329.html\">《WebRTC实时互动直播技术入门与实战》</a> ，这门课里对其原理做了说细阐述。</li>\n<li>第二个参数，是 RTCMediaConstraints 类型对象，也就是对 RTCPeerConnection 的限制。如，是否接收视频数据？是否接收音频数据？如果要与浏览器互通还要开启 <strong>DtlsSrtpKeyAgreement</strong> 选项。</li>\n<li>第三个参数，是<strong>委拖</strong>类型。相当于给 RTCPeerConnection 设置一个<strong>观察者</strong>。这样RTCPeerConnection 可以将一个状态/信息通过它通知给<strong>观察者</strong>。但它并不属于<strong>观察者</strong>模式，这一点大家一定要清楚。</li>\n</ul></view><view class=\"cl-preview-section\"><p><strong>RTCPeerConnection</strong> 对象创建好后，接下来我们介绍的是整个实时通话过程中，最重要的一部分知识，那就是 <strong>媒体协商</strong>。</p>\n</view><view class=\"cl-preview-section\"><h3>媒体协商</h3>\n</view><view class=\"cl-preview-section\"><p>首先，我们要知道媒体协商内容使用是 SDP 协议，不了解这部分知识的同学可以看 <a href=\"https://coding.imooc.com/class/329.html\">《WebRTC实时互动直播技术入门与实战》</a> 这门课，在门课里对其做了详细讲解。</p>\n</view><view class=\"cl-preview-section\"><p>其次，我们要清楚整体媒体协商的过程。</p>\n</view><view class=\"cl-preview-section\"><p>iOS 端的媒体协商过程与 Android/JS 端是一模一样的。还是下面这个经典的图:</p>\n</view><view class=\"cl-preview-section\"><p><img class=\"lazyload\" src=\"https://upload-images.jianshu.io/upload_images/5956443-787035ecac6e8d3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" data-original=\"https://upload-images.jianshu.io/upload_images/5956443-787035ecac6e8d3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"媒体协商\" style=\"width:100%;\"></p>\n</view><view class=\"cl-preview-section\"><p>A 与 B 进行通话，通话的发起方，首先要创建 <strong>Offer</strong> 类型的 SDP 内容。之后调用 RTCPeerConnection 对象的 <strong>setLocalDescription</strong> 方法，将 <strong>Offer</strong> 保存到本地。</p>\n</view><view class=\"cl-preview-section\"><p>紧接着，将 <strong>Offer</strong> 发送给服务器。然后，通过信令服务器中转到被呼叫方。被呼叫方收到 <strong>Offer</strong> 后，调用它的 RTCPeerConnection 对象的 <strong>setRemoteDescription</strong> 方法，将远端的 <strong>Offer</strong> 保存起来。</p>\n</view><view class=\"cl-preview-section\"><p>之后，被呼到方创建 <strong>Answer</strong> 类型的 SDP 内容，并调用 RTCPeerConnection 对象的 <strong>setLocalDescription</strong> 方法将它存储到本地。</p>\n</view><view class=\"cl-preview-section\"><p>同样的，它也要将 <strong>Answer</strong> 发送给服务器。服务器收到该消息后，不做任何处理，直接中转给呼叫方。呼叫方收到 <strong>Answer</strong> 后，调用 <strong>setRemoteDescription</strong> 将其保存起来。</p>\n</view><view class=\"cl-preview-section\"><p>通过上面的步骤，整个<strong>媒体协商</strong>部分就完成了。</p>\n</view><view class=\"cl-preview-section\"><p>下面我们就具体看看，在 iOS 端是如何实现这个逻辑的：</p>\n</view><view class=\"cl-preview-section\"><pre><code>...\n\n[peerConnection offerForConstraints:[self defaultPeerConnContraints]\n                  completionHandler:^(RTCSessionDescription * _Nullable sdp, NSError * _Nullable error) {\n                      if(error){\n                          NSLog(@\"Failed to create offer SDP, err=%@\", error);\n                      } else {\n                          __weak RTCPeerConnection* weakPeerConnction = self->peerConnection;\n                          [self setLocalOffer: weakPeerConnction withSdp: sdp];\n                      }\n                  }];\n...\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>在iOS端使用 RTCPeerConnection 对象的 <strong>offerForConstraints</strong> 方法创建 <strong>Offer</strong> SDP。它有两个参数：</p>\n</view><view class=\"cl-preview-section\"><ul><li>一个是 RTCMediaConstraints 类型的参数，该参数我们在前面创建 RTCPeerConnection 对象时介绍过，这里不在赘述。</li>\n<li>另一个参数是一个匿名回调函数。可以通过对  <strong>error</strong> 是否为空来判定 <strong>offerForConstraints</strong> 方法有没有执行成功。如果执行成功了，参数 <strong>sdp</strong> 就是创建好的 SDP 内容。</li>\n</ul></view><view class=\"cl-preview-section\"><p>如果成功获得了 <strong>sdp</strong>，按照之前的处理流程描述，我们首先要将它只存到本地；然后再将它发送给他务器，服务器中转给另一端。</p>\n</view><view class=\"cl-preview-section\"><p>我们的代码也是严格按照这个过程来的。在上面代码中 <strong>setLocalOffer</strong> 方法就是做这件事儿。具体代码如下：</p>\n</view><view class=\"cl-preview-section\"><pre><code>...\n[pc setLocalDescription:sdp completionHandler:^(NSError * _Nullable error) {\n        if (!error) {\n            NSLog(@\"Successed to set local offer sdp!\");\n        }else{\n            NSLog(@\"Failed to set local offer sdp, err=%@\", error);\n        }\n    }];\n    \n__weak NSString* weakMyRoom = myRoom;\ndispatch_async(dispatch_get_main_queue(), ^{\n    \n    NSDictionary* dict = [[NSDictionary alloc] initWithObjects:@[@\"offer\", sdp.sdp]\n                                                       forKeys: @[@\"type\", @\"sdp\"]];\n    \n    [[SignalClient getInstance] sendMessage: weakMyRoom\n                                    withMsg: dict];\n});\n...\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>从上面的代码可以清楚的看出，它做了两件事儿。一是调用 <strong>setLocalDescription</strong> 方法将 sdp 保存到本地；另一件事儿就是发送消息；</p>\n</view><view class=\"cl-preview-section\"><p>所以，通过上面的描述大家也就知道后面的所有逻辑了。这里我们就不一一展开来讲了。</p>\n</view><view class=\"cl-preview-section\"><p>当整个协商完成之后，紧接着，在WebRTC底层就会进行音视频数据的传输。如果远端的视频数据到达本地后，我们就需要将它展示到界面上。这又是如何做到的呢？</p>\n</view><view class=\"cl-preview-section\"><h3>渲染远端视频</h3>\n</view><view class=\"cl-preview-section\"><p>大家是否还记得，在我们创建 RTCPeerConnection 对象时，同时给RTCPeerConnection设置了一个<strong>委拖</strong>，在我们的项目中就是 <strong>CallViewController</strong> 对象。在该对象中我们实现了所有 <strong>RTCPeerConnection</strong> 对象的代理方法。其中比较关键的有下面几个：</p>\n</view><view class=\"cl-preview-section\"><ul><li>\n<p>(void)peerConnection:(RTCPeerConnection *)peerConnection<br>\ndidGenerateIceCandidate:(RTCIceCandidate *)candidate；该方法用于收集可用的 Candidate。</p>\n</li>\n<li>\n<p>(void)peerConnection:(RTCPeerConnection *)peerConnection<br>\ndidChangeIceConnectionState:(RTCIceConnectionState)newState；当 ICE 连接状态发生变化时会触发该方法</p>\n</li>\n<li>\n<p>(void)peerConnection:(RTCPeerConnection *)peerConnection<br>\ndidAddReceiver:(RTCRtpReceiver *)rtpReceiver<br>\nstreams:(NSArray<RTCMediaStream *> *)mediaStreams；该方法在侦听到远端 track 时会触发。</p>\n</li>\n</ul></view><view class=\"cl-preview-section\"><p>那么，什么时候开始渲染远端视频呢？当有远端视频流过来的时候，就会触发  (void)peerConnection:(RTCPeerConnection *)peerConnection<br>\ndidAddReceiver:(RTCRtpReceiver *)rtpReceiver<br>\nstreams:(NSArray<RTCMediaStream *> *)mediaStreams 方法。所以我们只需要在该方法中写一些逻辑即可。</p>\n</view><view class=\"cl-preview-section\"><p>当上面的函数被调用后，我们可以通过 <strong>rtpReceiver</strong> 参数获取到 <strong>track</strong>。这个track有可能是音频trak，也有可能是视频trak。所以，我们首先要对 track 做个判断，看其是视频还是音频。</p>\n</view><view class=\"cl-preview-section\"><p>如果是视频的话，就将remoteVideoView加入到trak中，相当于给track添加了一个观察者，这样remoteVideoView就可以从track获取到视频数据了。在 <strong>remoteVideoView</strong> 实现了渲染方法，一量收到数据就会直接进行渲染。最终，我们就可以看到远端的视频了。</p>\n</view><view class=\"cl-preview-section\"><p>具体代码如下：</p>\n</view><view class=\"cl-preview-section\"><pre><code>...\nRTCMediaStreamTrack* track = rtpReceiver.track;\nif([track.kind isEqualToString:kRTCMediaStreamTrackKindVideo]){\n   \n    if(!self.remoteVideoView){\n        NSLog(@\"error:remoteVideoView have not been created!\");\n        return;\n    }\n    \n    remoteVideoTrack = (RTCVideoTrack*)track;\n  \t\n  \t [remoteVideoTrack addRenderer: self.remoteVideoView];\n}\n   \n...\n\n</code></pre>\n</view><view class=\"cl-preview-section\"><p>通过上面的代码，我们就可以将远端传来的视频展示出来了。</p>\n</view><view class=\"cl-preview-section\"><h2>小结</h2>\n</view><view class=\"cl-preview-section\"><p>以上我就将 iOS 端实现1对1实时通话的整体逻辑讲解完了。整体来看，其过程与 js/Android 端基本上是一模一样的。</p>\n</view><view class=\"cl-preview-section\"><p>在本文中，我通过对下面几个主题的介绍，向大家完整的讲解了 iOS 端该如何实现一个实时音视频通话程序：</p>\n</view><view class=\"cl-preview-section\"><ul><li>权限申请</li>\n<li>引入 WebRTC 库</li>\n<li>采集并显示本地视频</li>\n<li>信令驱动</li>\n<li>创建音视频数据通道</li>\n<li>媒体协商</li>\n<li>渲染远端视频</li>\n</ul></view><view class=\"cl-preview-section\"><p>对于一个熟悉 iOS 的开发者来说，通过本文的讲解，应该可以很快写出这样一个实时通话的程序。</p>\n</view><view class=\"cl-preview-section\"><p>谢谢！</p>\n</view><view class=\"cl-preview-section\"><p>##参考资料<br><a href=\"https://coding.imooc.com/class/329.html?mc_marking=59909dfb407cd07d4f3998dbc2d45c49&mc_channel=shouji\">《WebRTC实时互动直播技术入门与实战》</a></p>\n</view>\n\t\t\t\t\t",
                "cover": [
                    "https://upload-images.jianshu.io/upload_images/5956443-16123c09ff144469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640",
                    "https://upload-images.jianshu.io/upload_images/5956443-2f71ce4133ec8484.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",
                    "https://upload-images.jianshu.io/upload_images/5956443-787035ecac6e8d3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"
                ],
                "mode": "column"
            },
            {
                "id": "292698",
                "title": "安卓从开发到逆向（二）java转换为smali对比分析",
                "browse_count": 945,
                "collection_count": 0,
                "comments_count": 0,
                "author": {
                    "id": "6685330",
                    "author_name": "大壮老师",
                    "avatar": "//img3.sycdn.imooc.com/54584f850001c0bc02200220-160-160.jpg",
                    "status": "normal"
                },
                "classify": "后端开发",
                "thumbs_up_count": 0,
                "create_time": "2019.09.21 17:07",
                "content": "\n\t\t\t\t\t\t<p>首先我们需要知道一个<a href=\"https://coding.imooc.com/class/283.html?mc_marking=561de3fb1745767d54fb64fc6c1604db&mc_channel=shouji\" target=\"_self\">知识点</a>：</p><pre>java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码。传统的java程序经过编译，生成java字节码并保存在class文件中，java虚拟机通过解码class文件的内容来运行程序，而dalvik虚拟机运行的是dalvik字节码，所有dalvik字节码由java字节码转换而来，并被打包到一个DEX可执行文件当中，dalvik虚拟机通过解释DEX文件来执行这些字节码。</pre><p>破解软件下载地址：</p><pre>链接：https://pan.baidu.com/s/1mHOl9y-LXnETUg3oDAKNvA \n提取码：3ygd</pre><p>准备工具：</p><pre>转换工具：J2S2J</pre><p>首先我们来看一段JAVA代码</p><p><img class=\"lazyload\" src=\"http://img4.sycdn.imooc.com/5d85e78c00016b9405000271.jpg\" data-original=\"http://img4.sycdn.imooc.com/5d85e78c00016b9405000271.jpg\" img_width=\"692\" img_height=\"374\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img1.sycdn.imooc.com/5d85e78c00016b9406920374.jpg\" title></p><p><br></p><p>很简单的一段JAVA代码，定义了一个foo方法，传入两个int类型的参数，返回(a+b)*(a-b)，在main方法中进行了调用，传入5和3，并打印出来。</p><p>接下来，我们通过J2S2J转换为smali</p><p><img class=\"lazyload\" src=\"http://img1.sycdn.imooc.com/5d85e7960001b02605000237.jpg\" data-original=\"http://img1.sycdn.imooc.com/5d85e7960001b02605000237.jpg\" img_width=\"1833\" img_height=\"866\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img4.sycdn.imooc.com/5d85e7960001b02618330866.jpg\" title></p><p><br></p><p>我们对比着JAVA代码，来读一下smali代码，如果你对smali一点都不熟悉，可以看一下这篇文章，写的非常好。</p><pre>https://blog.csdn.net/rozol/article/details/88368358</pre><p>我们来分析一下这段smali代码</p><p>代码头部</p><pre>创建了一个Hello类\n.class public LHello;\n该类继承于object\n.super Ljava/lang/Object;\n原文件名称为Hello.java\n.source \"Hello.java\"</pre><p>构造方法，该段未在java代码中显示，java中默认有一个隐藏的无参数的构造方法</p><p><img class=\"lazyload\" src=\"http://img3.sycdn.imooc.com/5d85e7a000019e1805000216.jpg\" data-original=\"http://img3.sycdn.imooc.com/5d85e7a000019e1805000216.jpg\" img_width=\"721\" img_height=\"311\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img2.sycdn.imooc.com/5d85e7a000019e1807210311.jpg\" title></p><p><br></p><p>主方法</p><p><img class=\"lazyload\" src=\"http://img2.sycdn.imooc.com/5d85e7aa0001a48d05000450.jpg\" data-original=\"http://img2.sycdn.imooc.com/5d85e7aa0001a48d05000450.jpg\" img_width=\"887\" img_height=\"798\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img2.sycdn.imooc.com/5d85e7aa0001a48d08870798.jpg\" title></p><p><br></p><p>自定义的foo方法</p><p><img class=\"lazyload\" src=\"http://img1.sycdn.imooc.com/5d85e7b50001b00504300440.jpg\" data-original=\"http://img1.sycdn.imooc.com/5d85e7b50001b00504300440.jpg\" img_width=\"430\" img_height=\"440\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img4.sycdn.imooc.com/5d85e7b50001b00504300440.jpg\" title></p><p><br></p><p>如上所示，我们解析了一段简单的JAVA代码到smali。</p><p>接下来，我们可以加一点点难度，写一个for循环</p><p><img class=\"lazyload\" src=\"http://img2.sycdn.imooc.com/5d85e7bf0001c06d05000376.jpg\" data-original=\"http://img2.sycdn.imooc.com/5d85e7bf0001c06d05000376.jpg\" img_width=\"635\" img_height=\"477\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img1.sycdn.imooc.com/5d85e7bf0001c06d06350477.jpg\" title></p><p><br></p><p>还是使用J2S2J转换为smali，本次我们仅分析for_test_method方法</p><p><img class=\"lazyload\" src=\"http://img2.sycdn.imooc.com/5d85e7ca00015aa505000476.jpg\" data-original=\"http://img2.sycdn.imooc.com/5d85e7ca00015aa505000476.jpg\" img_width=\"928\" img_height=\"882\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img1.sycdn.imooc.com/5d85e7ca00015aa509280882.jpg\" title></p><p><br></p><p>代码参考：</p><p><a href=\"https://github.com/freedom-wy/reverse_android\" _class=\"lazyload\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" data-original=\"https://github.com/freedom-wy/reverse_android\">https://github.com/freedom-wy/reverse_android</a>   中smali笔记</p><p>欢迎交流，一起学习，一起进步。</p><p>另外，我在慕课网上主讲课程：<a href=\"https://coding.imooc.com/class/283.html?mc_marking=561de3fb1745767d54fb64fc6c1604db&mc_channel=shouji\" target=\"_self\" title=\"《python爬虫工程师必学--App数据抓取实战》\" textvalue=\"《python爬虫工程师必学--App数据抓取实战》\">《python爬虫工程师必学--App数据抓取实战》</a></p><p>还请各位大神多多支持。</p><p><br></p>\n\t\t\t\t\t",
                "cover": [
                    "http://img4.sycdn.imooc.com/5d85e78c00016b9405000271.jpg",
                    "http://img1.sycdn.imooc.com/5d85e7960001b02605000237.jpg",
                    "http://img3.sycdn.imooc.com/5d85e7a000019e1805000216.jpg",
                    "http://img2.sycdn.imooc.com/5d85e7aa0001a48d05000450.jpg",
                    "http://img1.sycdn.imooc.com/5d85e7b50001b00504300440.jpg",
                    "http://img2.sycdn.imooc.com/5d85e7bf0001c06d05000376.jpg",
                    "http://img2.sycdn.imooc.com/5d85e7ca00015aa505000476.jpg"
                ],
                "mode": "column"
            },
            {
                "id": "292504",
                "title": "安卓从开发到逆向（一）登录demo逆向破解",
                "browse_count": 1877,
                "collection_count": 6,
                "comments_count": 1,
                "author": {
                    "id": "6685330",
                    "author_name": "大壮老师",
                    "avatar": "//img3.sycdn.imooc.com/54584f850001c0bc02200220-160-160.jpg",
                    "status": "normal"
                },
                "classify": "后端开发",
                "thumbs_up_count": 6,
                "create_time": "2019.09.16 23:39",
                "content": "\n\t\t\t\t\t\t<p><img class=\"lazyload\" src=\"http://img3.sycdn.imooc.com/5d7fab9e0001dfcb05000320.jpg\" data-original=\"http://img3.sycdn.imooc.com/5d7fab9e0001dfcb05000320.jpg\" alt=\"http://img2.sycdn.imooc.com/5d7fab9e0001dfcb05900377.jpg\" style=\"width:100%;\"></p><p>apk及破解软件下载地址：</p><pre>链接：https://pan.baidu.com/s/1mHOl9y-LXnETUg3oDAKNvA \n提取码：3ygd</pre><p><strong>破解要求：</strong></p><p>即使用户名密码输入错误，也显示登录成功。</p><p>======================================================</p><p><strong>准备工具：</strong></p><pre>开发工具android studio3.4.1，破解工具android killer1.3.1，夜神安卓模拟器</pre><p>开发步骤：</p><p>1、在android studio中创建Project，选择空白activity，填入项目名称，包名，项目保存地址，运行平台等，点击finish，开始创建项目</p><p><img class=\"lazyload\" src=\"http://img1.sycdn.imooc.com/5d7fabb60001bf3205000321.jpg\" data-original=\"http://img1.sycdn.imooc.com/5d7fabb60001bf3205000321.jpg\" img_width=\"1131\" img_height=\"724\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img2.sycdn.imooc.com/5d7fabb60001bf3211310724.jpg\" title></p><p><br></p><p>2、项目创建完成后，会在当前目录中创建好模块app，并展示MainActivity.java文件</p><p><img class=\"lazyload\" src=\"http://img3.sycdn.imooc.com/5d7fabc00001608c05000160.jpg\" data-original=\"http://img3.sycdn.imooc.com/5d7fabc00001608c05000160.jpg\" img_width=\"1474\" img_height=\"471\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img4.sycdn.imooc.com/5d7fabc00001608c14740471.jpg\" title></p><p><br></p><p>3、需要注意三个文件，分别为src\\mainAndroidManifest.xml（应用清单文件），java\\com\\dazhuang\\login\\MainActivity.java（安卓工程默认主文件），res\\layout\\activity_main.xml（界面布局文件）</p><p>4、修改界面布局文件，编辑出登录demo界面</p><p><img class=\"lazyload\" src=\"http://img3.sycdn.imooc.com/5d7fabcf0001978305000273.jpg\" data-original=\"http://img3.sycdn.imooc.com/5d7fabcf0001978305000273.jpg\" img_width=\"1492\" img_height=\"814\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img2.sycdn.imooc.com/5d7fabcf0001978314920814.jpg\" title></p><p><br></p><p>5、编辑安卓工程默认主文件MainActivity.java，编辑登录逻辑</p><p><img class=\"lazyload\" src=\"http://img4.sycdn.imooc.com/5d7fabde0001253105000294.jpg\" data-original=\"http://img4.sycdn.imooc.com/5d7fabde0001253105000294.jpg\" img_width=\"1439\" img_height=\"846\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img1.sycdn.imooc.com/5d7fabde0001253114390846.jpg\" title></p><p><br></p><p>6、连接夜神模拟器，并运行app，点击android studio的运行键，android studio会自动连接夜神安卓模拟器，并发送app到模拟器上，进行安装和运行</p><p><img class=\"lazyload\" src=\"http://img1.sycdn.imooc.com/5d7fabea0001a92305000081.jpg\" data-original=\"http://img1.sycdn.imooc.com/5d7fabea0001a92305000081.jpg\" img_width=\"902\" img_height=\"145\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img4.sycdn.imooc.com/5d7fabea0001a92309020145.jpg\" title></p><p><br></p><p><img class=\"lazyload\" src=\"http://img1.sycdn.imooc.com/5d7fabf90001dfcb05000320.jpg\" data-original=\"http://img1.sycdn.imooc.com/5d7fabf90001dfcb05000320.jpg\" img_width=\"590\" img_height=\"377\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img4.sycdn.imooc.com/5d7fabf90001dfcb05900377.jpg\" title></p><p><br></p><p>7、根据MainActivity.java文件，我们可以知道，用户名为admin，密码为admin888，当我们输入正确的用户名密码时，app会弹出消息登录成功，否则弹出消息，登录失败。</p><p><strong>破解方法：</strong></p><p>1、使用android killer反编译app</p><p><img class=\"lazyload\" src=\"http://img3.sycdn.imooc.com/5d7fac0600013f9405000223.jpg\" data-original=\"http://img3.sycdn.imooc.com/5d7fac0600013f9405000223.jpg\" img_width=\"1064\" img_height=\"473\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img3.sycdn.imooc.com/5d7fac0600013f9410640473.jpg\" title></p><p><br></p><p>2、找到MainActivity$login_button.smali</p><p><img class=\"lazyload\" src=\"http://img4.sycdn.imooc.com/5d7fac270001a41605000391.jpg\" data-original=\"http://img4.sycdn.imooc.com/5d7fac270001a41605000391.jpg\" img_width=\"992\" img_height=\"775\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img4.sycdn.imooc.com/5d7fac270001a41609920775.jpg\" title></p><p><br></p><p>3、修改代码，在.line 40下添加:cond_1</p><p>smali代码相关示意详见：</p><pre>https://github.com/freedom-wy/reverse_android/tree/master/project/app</pre><p><img class=\"lazyload\" src=\"http://img4.sycdn.imooc.com/5d7fac380001ca1005000197.jpg\" data-original=\"http://img4.sycdn.imooc.com/5d7fac380001ca1005000197.jpg\" img_width=\"1229\" img_height=\"482\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img3.sycdn.imooc.com/5d7fac380001ca1012290482.jpg\" title></p><p><br></p><p>4、修改判断语句后的执行结果，将cond_0改为cond_1</p><p><img class=\"lazyload\" src=\"http://img4.sycdn.imooc.com/5d7fac4600017c4305000266.jpg\" data-original=\"http://img4.sycdn.imooc.com/5d7fac4600017c4305000266.jpg\" img_width=\"955\" img_height=\"508\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img2.sycdn.imooc.com/5d7fac4600017c4309550508.jpg\" title></p><p><br></p><p>5、重新编译apk</p><p><img class=\"lazyload\" src=\"http://img3.sycdn.imooc.com/5d7fac5800017dc105000079.jpg\" data-original=\"http://img3.sycdn.imooc.com/5d7fac5800017dc105000079.jpg\" img_width=\"1087\" img_height=\"171\" data-story_id=\"0\" data-image_ids=\"[]\" style=\"width:100%;\" alt=\"http://img2.sycdn.imooc.com/5d7fac5800017dc110870171.jpg\" title></p><p><br></p><p>apk重新编译后，会生成在AndroidKiller_v1.3.1\\AndroidKiller_v1.3.1\\projects\\login-release\\Bin下，名称为login-release_killer.apk</p><p>6、再次运行，无论输入什么用户名密码，弹出的消息都是登录成功了。</p><p>代码参考：</p><pre>https://github.com/freedom-wy/reverse_android/tree/master/project/login</pre><p>欢迎交流，一起学习，一起进步。</p><p>另外，我在慕课网上主讲课程：</p><p><a href=\"https://coding.imooc.com/class/283.html?mc_marking=561de3fb1745767d54fb64fc6c1604db&mc_channel=shouji\" target=\"_self\" title=\"《python爬虫工程师必学--App数据抓取实战》\" textvalue=\"《python爬虫工程师必学--App数据抓取实战》\">《python爬虫工程师必学--App数据抓取实战》</a>还请各位大神多多支持。</p><p><br></p>\n\t\t\t\t\t",
                "cover": [
                    "http://img3.sycdn.imooc.com/5d7fab9e0001dfcb05000320.jpg",
                    "http://img1.sycdn.imooc.com/5d7fabb60001bf3205000321.jpg",
                    "http://img3.sycdn.imooc.com/5d7fabc00001608c05000160.jpg",
                    "http://img3.sycdn.imooc.com/5d7fabcf0001978305000273.jpg",
                    "http://img4.sycdn.imooc.com/5d7fabde0001253105000294.jpg",
                    "http://img1.sycdn.imooc.com/5d7fabea0001a92305000081.jpg",
                    "http://img1.sycdn.imooc.com/5d7fabf90001dfcb05000320.jpg",
                    "http://img3.sycdn.imooc.com/5d7fac0600013f9405000223.jpg",
                    "http://img4.sycdn.imooc.com/5d7fac270001a41605000391.jpg",
                    "http://img4.sycdn.imooc.com/5d7fac380001ca1005000197.jpg",
                    "http://img4.sycdn.imooc.com/5d7fac4600017c4305000266.jpg",
                    "http://img3.sycdn.imooc.com/5d7fac5800017dc105000079.jpg"
                ],
                "mode": "column"
            },
            {
                "id": "301818",
                "title": "常见adb命令",
                "browse_count": 87,
                "collection_count": 0,
                "comments_count": 0,
                "author": {
                    "id": "6433657",
                    "author_name": "风落几番",
                    "avatar": "//img1.sycdn.imooc.com/5b2a0c4d0001029d09600960-160-160.jpg",
                    "status": "normal"
                },
                "classify": "每日一题",
                "thumbs_up_count": 0,
                "create_time": "2020.03.11 16:27",
                "content": "\n\t\t\t\t\t\t<p>1. 显示系统中全部设备： </p><p>adb devices </p><p>2.开启ADB服务： </p><p>adb start-server </p><p>3.关闭ADB服务： </p><p>adb kill-server </p><p>停止 adb 服务</p><p>4.连接设备： </p><p>adb connect 192.168.1.66  </p><p>5.断开设备： </p><p>adb disconnect 192.168.1.66</p><p>6.安装一个apk <br></p><p>adb install -r (APK路径) </p><p>7.直接卸载： </p><p>adb uninstall （apk包名） </p><p>8.列出手机装的所有app的包名： </p><p>adb shell pm list packages</p><p>9.清除应用数据与缓存： </p><p>adb shell pm clear （apk包名）</p><p>10.启动应用 </p><p>adb shell am start -n com.helloshan.demo/.MianActivity </p><p>11.强制停止应用 </p><p>需要强制停止应用，则执行以下命令： </p><p>adb shell am force-stop （apk包名） </p><p>12.删除系统应用： </p><p>adb remount （重新挂载系统分区，使系统分区重新可写）。 </p><p>adb shell </p><p>cd system/app/ </p><p>ls </p><p>rm *.apk </p><p>12.杀死某个进程：(三个步骤) </p><p>adb shell </p><p>ps </p><p>kill pid </p><p>ps是查看进程命令，kill pid 你想结束的进程 </p><p>13.获取文件的读写权限： </p><p>adb remount </p><p>有些设备并不能直接adb remount，必须要先以root身份进入，先执行adb root，在执行adb remount </p><p>14.查看日志: </p><p>adb logcat</p><p>15.常用操作文件夹命令 </p><p>操作文件和文件夹有时会出现权限不够，Read-only file system。就需要adb remount 操作，获得权限。 </p><p>cd system/sd/data //进入系统内指定文件夹 </p><p>ls //列表显示当前文件夹内容 </p><p>mkdir xxx //创建xxx的文件夹 </p><p>rm -r xxx //删除名字为xxx的文件夹及其里面的所有文件 </p><p>rm xxx //删除文件xxx </p><p>rmdir xxx //删除xxx的文件夹</p><p><br></p>\n\t\t\t\t\t",
                "cover": [],
                "mode": "base"
            },
            {
                "id": "298932",
                "title": "面对职场的“裁员潮”，“抢功劳”，“瞎指挥”，“薪资倒挂”，程序员们何去何从",
                "browse_count": 5058,
                "collection_count": 21,
                "comments_count": 4,
                "author": {
                    "id": "6433657",
                    "author_name": "风落几番",
                    "avatar": "//img1.sycdn.imooc.com/5b2a0c4d0001029d09600960-160-160.jpg",
                    "status": "normal"
                },
                "classify": "职场生活",
                "thumbs_up_count": 21,
                "create_time": "2020.01.02 16:49",
                "content": "\n\t\t\t\t\t\t<h2><a href=\"http://www.imooc.com/read/62?mc_marking=9d1b0be85540901e20d3310338bea1a4&mc_channel=shouji\" target=\"_self\">写在前边的话</a></h2><p>每次提起程序员的“<a href=\"http://www.imooc.com/read/62?mc_marking=9d1b0be85540901e20d3310338bea1a4&mc_channel=shouji\" target=\"_self\">情商</a>”，大家脑海里想到的故事都是这样的：</p><p><img class=\"lazyload\" src=\"https://img1.sycdn.imooc.com/5dfc48470001d0c605200311.png\" data-original=\"https://img1.sycdn.imooc.com/5dfc48470001d0c605200311.png\"  style=\"width:100%;\"></p><p>或者是这样的：</p><p><img class=\"lazyload\" src=\"https://img1.sycdn.imooc.com/5dfc488a00011b8b04960312.png\" data-original=\"https://img1.sycdn.imooc.com/5dfc488a00011b8b04960312.png\"  style=\"width:100%;\"></p><p>看到这样的故事和这样的调侃，我都有一点奇怪：我们程序员啊，或许情商不太高，但是也并<strong>不是智障</strong>好不好。至少像这样故事中“退化”到这种程度的程序员，我在工作这么多年以来，从来没有见过，这样的“<strong>情商故事</strong>”更多是杜撰出来的玩笑而已，而且仔细想想吧，这玩笑的杜撰者或许大概还必须自己得是个程序员。</p><p>所以，我们来聊一聊在我身边比较典型的“<strong>情商不足</strong>”的人。</p><h2>浅谈情商</h2><p>先来说说我们生活中见过比较多的一种类型：<strong>过于自信，目空一切</strong>。</p><p><img class=\"lazyload\" src=\"https://img1.sycdn.imooc.com/5dfc48aa0001e5ee01900224.png\" data-original=\"https://img1.sycdn.imooc.com/5dfc48aa0001e5ee01900224.png\"  style=\"width:100%;\"></p><p>很肯定的是，程序员本来就是非常非常有自信的一种职业，我也不例外。我会对我自己写的每一行代码都爱不释手，鄙视一切其他人的代码甚至是自己过去的代码。其实这并不要紧，但是把这份自信无限制的放大到职场中，就适得其反了。职场有规则与价值观，放飞自我的任性，要出现在适合的地方。</p><p><em>我有一个前同事，技术能力非常出色，只是脾气非常火爆，经常称自己性子直，无论是领导还是同事，一言不合便“喷”了起来。开始还是以居高临下的姿态面对别人，最喜欢对别的程序员说教，不允许别人说自己不对，后来呢变成老板交代的工作，表面答应很好，之后推脱给别人去做，出了问题再各种借口。于是朋友寥寥，也有好心的同事提醒过他，但他总认为自己的资历深能力强，老板离不开他，不会把他怎么样。</em></p><p>事实是，无论你再有才华，持才傲物就是职场大忌了。越是在职场，越是要遵守职场的规则。地球离开谁都照样转，公司缺了谁都不会倒闭，时至今日，我还从来没有发现有什么“缺你不可”的事儿。</p><p>所以，如果你认为你非常重要，可以享受一些特权，那么对不起，你一定是想多了。</p><p><br></p><p>也有那么一种人，是那种自认为幽默感非常足，<strong>喜欢开玩笑却没分寸</strong>的人。</p><p><img class=\"lazyload\" src=\"https://img1.sycdn.imooc.com/5dfc48cc0001bef502660250.png\" data-original=\"https://img1.sycdn.imooc.com/5dfc48cc0001bef502660250.png\"  style=\"width:100%;\"></p><p>幽默这件事吧，我觉得我自己稍微有一点发言权。我是一个土生土长的天津人，所以从蹒跚学步开始就少不了受到相声的教育，大一点了呢，无论是茶馆还是澡堂，处处弥漫着马志明先生的教诲。上了大学加入过相声社，打过快板说过相声，乃至到现在有了十来年的讲师经历，想必幽默这件事我肯定比不了专家，但是在诸位面前应该还是有点话语权的。</p><p>幽默确实是个技术含量非常高的活儿，有的人会觉得自己很好笑，各种“妙语连珠”，其实往往是流于恶俗，没有分寸。还是讲个例子吧。</p><p><em>我曾经有过这样一个同事，说“曾经”，想必大家也猜到了现在的结果。这是个比较愿意去活跃团队气氛的人。某一次，我们部门与其他部门配合一个项目，我们部门有一个长相一般的小姑娘受到了对方项目经理的夸赞，这时候，我们的“幽默大师”出现了：</em></p><p><em><img class=\"lazyload\" src=\"https://img1.sycdn.imooc.com/5dfc48e90001113403840338.png\" data-original=\"https://img1.sycdn.imooc.com/5dfc48e90001113403840338.png\"  style=\"width:100%;\"></em></p><p>不要觉得你是在“吐槽大会”上，职场不是如来吐槽的，黑色幽默拿来自黑是“幽默”，用来黑别人那就惹人反感了。所以，请不要滥用自己的“幽默”，给幽默增加一点深度，过犹不及。</p><p><br></p><p>还有一种，也是最多的一种吧，就是<strong>喜欢抱怨，光说不练</strong>。当然，抱怨本身没有问题，这是一种人生态度和性格，我们不能强加更改，更核心的在于“<strong>只抱怨</strong>”。</p><p><img class=\"lazyload\" src=\"https://img1.sycdn.imooc.com/5dfc49090001b9ca01700187.png\" data-original=\"https://img1.sycdn.imooc.com/5dfc49090001b9ca01700187.png\"  style=\"width:100%;\"></p><p>我刚工作的时候，有一个同事，现在关系也还不错，平时呢，我们偶尔出来聚个小餐、喝口小酒，顺便“工作的烦恼和哥们说说，上司的事情跟朋友谈谈”。最常挂在嘴边的话是：<strong>我真是受够了！这都是哪来的XX领导</strong>（请原谅我用XX替换掉在电视里应该开始哔的音效，自行填空）！接下来就是各种抱怨。</p><p>我得承认，每个人都喜欢抱怨，我也一样。然而多年的职场磨砺告诉我，没有任何一份工作是完美的。<strong>轻松愉快的工资少，给钱多的得加班，加班少的要心眼，要是真有一份工作机会告诉你工资多、不加班、办公环境好，那估计八成这是要把你卖到东南亚</strong>。尴尬不？其实不管在江河湖海还是在池塘，不会游泳的你还是不会游泳。</p><p>抱怨归抱怨，如果你一直停留在“领导看我不顺眼”这种思维里边，你就永远是一个“受害者”。真正的情商高的人会：<strong>大声抱怨，大口吃肉，然后扶石探路，摸索着前进</strong>。</p><p>所以，同志们，不是告诉大家不要抱怨，而是不要停留在抱怨，积极面对困境，毕竟“人在江湖飘，谁能不挨刀”，但是，“既在江湖飘，哪能总挨刀”，只要人在江湖，难忍的问题还是会在不经意的瞬间神出鬼没，并不会以你的意志为转移。也更加不是换一份工作就可以躲避的，唯一能做的就是<strong>修炼</strong>。挨欺负要总结，被针对要思考，具体的呢，我们后边聊。</p><h2>论“老实人”</h2><p>这个时候，估计又有同学要说了，风落啊，你说的这些例子都太极端了，而且都是他们个人原因，我可跟他们不一样，我是个<strong>老实人</strong>。</p><p>说到老实人这个词，在我年少无知的时候，这还是一个褒义词，至于现在，小灰下边的表情告诉你答案：</p><p><img class=\"lazyload\" src=\"https://img1.sycdn.imooc.com/5dfc492b0001701701960267.png\" data-original=\"https://img1.sycdn.imooc.com/5dfc492b0001701701960267.png\"  style=\"width:100%;\"></p><p>实际上职场上纯正的老实人怕是不多了，但是很多人会有“老实人”的特征，这在职场上也是吃不消的。我在写这篇专栏的时候，特意好好回顾了一下身边的老实人，大体上有这么几类：</p><p><strong>“讨好型”老实人</strong></p><p>很多人都有这种讨好型的人格，表现在职场里就是特别特别考虑别人的感受，既怕麻烦别人，更怕得罪别人。</p><p><em>比如，加班去吃饭，太累了忘记了叫小白一起去，回来就想：小白是不是会不高兴？也会在每次开会后考虑：我的发言、我说的话会不会不合适？</em></p><p><em>甚至工作中难免的摩擦，也要考虑：我说的话是不是不太合适？</em></p><p>FINE，就算“职场如战场”，但是我们是为自己而战。职场上不需要忽略自己，更不需要舍己为人。</p><p><strong>“好说话的”老实人</strong></p><p>太好说话、耳根子软的老实人在职场中比比皆是，无论别人说什么，他都觉得：可以，没问题。更有甚者，前一天刚被被人坑的死去活来，第二天别人随便恭维几句，立刻化干戈为玉帛，手牵手共同展望美好明天了。</p><p>这样的老实人是真的那么“好说话”，真的“那么好脾气”么？也不然。我之前招到过一个应届毕业的实习生，大体就是这样的“老实人”，别人让做什么做什么。后来实习期满结束，我请他吃饭送别，也问到了这个问题。</p><p><em>他说：其实我每天回去都不开心，都要骂自己，可是我觉得我才刚毕业，什么都不会，我再不听别人的话，人家更加不会教我东西了。人家不都说么，吃亏是福，我觉得吃亏也是好事吧？</em></p><p>虽然说来如此，但是别人就是会吃准了这套，不断的提要求，不断的削弱老实人的话语权，最后，你就什么都没有了。</p><p>所以我觉得，职场上的奥义在于：我们的目标可能不是想说就说，而是<strong>想说“不”就可以说“不”</strong>。当然，这很难，甚至我自己也不能做到（老板你还好吗o(<em>￣︶￣</em>)o），但至少在适当的时候给自己说“不”的权利，给自己说话的自由。</p><p><img class=\"lazyload\" src=\"https://img1.sycdn.imooc.com/5dfc494a0001a03b01760207.png\" data-original=\"https://img1.sycdn.imooc.com/5dfc494a0001a03b01760207.png\"  style=\"width:100%;\"></p><p><strong>“不会说话”的老实人</strong></p><p>这是我在职场中生活中最不想遇到的人，不知道该说他们直言爽快还是老实无脑，总之是既好笑又无奈。</p><p>有那么一个同事，别人呢，刚刚买了一套学区房，有人主动问起就非常高兴的跟大家聊起来，这个可爱的的同事呢，突然开始插嘴：<em>啊，其实吧，那个学校好多人都知道，不怎么样，攀比很严重还特别乱。</em>瞬间全场安静。</p><p>然而实际上，他既没有对象更没有孩子，当然，这样的“毒蛇”不知道啥时候才能有对象。</p><p>我不知道他在说这句话的时候是出于嫉妒还是只是表达自己知道的情况，毕竟我可舍不得买下帝都的学区房。这是不会说话的极端情况，但是想审视自己的同学，以后说话前可以多想一下：你的这句话会让别人有什么样的感受？</p><p>点名了寥寥几种老实人，实际上还有很多。比如好面子的老实人、不够积极主动的老实人，甚至是没有底线的老实人等等，老实人本身没问题，但是职场中这些所谓的“老实”反而成为了限制自身发展的“缺点”。</p><h2><a href=\"http://www.imooc.com/read/62?mc_marking=9d1b0be85540901e20d3310338bea1a4&mc_channel=shouji\" target=\"_self\">不一样的“情商课”</a></h2><p>其实这一趴我们应该叫“<strong>情商课之反躬自省篇</strong>”。大家尽情可以把自己跟上边的情商故事对比一下，先大体上看看自己到底有哪些不足，相信总可以描绘出一些自己的剪影。但是随着互联网时代的发展，软件行业的故事也在不断增多，面对不同的场景到底应该做什么、怎么做其实仍然是个大问题。</p><p>如果有熟悉我的朋友呢，可能知道，我是一个非常喜欢辩论的人，大学期间参加辩论赛后来又做领队的。喜欢到什么程度呢？这么说吧，我老婆一直不遗余力的想找渠道给我报名《奇葩说》！好吧，让大家失望的是，这么一大段夸奖自己的话并不是为了引入什么“将辩论带入职场”的思想，而是想起了《奇葩说》里黄执中说过的一段话：</p><blockquote><p><em>人生的困扰，说到底，十之八九，问题都出在人际关系。而人际关系的困扰，说到底，十之八九，都是因为沟通出了问题。</em></p><p><em>无论家庭、校园还是职场，无论亲情、爱情还是友情……生命中，我们绝大多数的纠结与困惑，愤怒与失落，根源，都来自我们怎么与别人对话、协商、争论、说服。</em></p></blockquote><p>所以，在我看来，真正的情商问题，是人际关系问题、是沟通问题，具体来说，是自我管理、与人沟通方式方法和心理态度方面的问题。</p><p>在这个专栏里，我并不想讲一些大道理，更不想用一些名人轶事来告诉大家：有情商应该怎么做事，我们应该学习黄渤、学习蔡康永的说话之道。混迹职场，失之一语，差之千里。我更愿意用一些“真实的”、“常见的”场景来细致剖析一下职场的情商。</p><p>曾经看过这么一句话，深以为然：</p><p><strong>职场上，一个人的智商决定了他是否能够走上成功的道路，而一个人的情商却决定他能在这条路上走多远。</strong></p><p>然而，没有谁是天生的情商高手，所以我们需要也应该付出时间去实践、提升，为自己开辟一条更宽阔的职场空间。</p><p>与君共勉。</p><p>我希望的，是我能够把我自己亲身经历的、有感而发的“职场那些事”分享给大家，希望能够对大家有所启迪和帮助。</p><p>最后，欢迎加入《<a href=\"http://www.imooc.com/read/62?mc_marking=9d1b0be85540901e20d3310338bea1a4&mc_channel=shouji\">程序员情商课</a>》，我是风落，让我们一起做”有情商“的程序高手。</p><p>————————————————————————————————————————————</p><p>小尾巴：</p><p>我是蚂蚁金服风落，一只撸过代码、做过测试、搞过运维、当过项目经理的程序猿，欢迎大家关注我：</p><p>传送门：<a href=\"https://www.imooc.com/t/6433657\" _class=\"lazyload\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\" data-original=\"https://www.imooc.com/t/6433657\">https://www.imooc.com/t/6433657</a> </p><p><strong>我的慕课专栏：</strong></p><p><a href=\"http://www.imooc.com/read/62?mc_marking=9d1b0be85540901e20d3310338bea1a4&mc_channel=shouji\" target=\"_blank\" textvalue=\"程序员情商课\">程序员情商课</a></p><p><a href=\"http://www.imooc.com/read/48?mc_marking=ee37b7e3ebd0f1c9dbae15dbc1fee33f&mc_channel=shouji\" target=\"_blank\" title=\"优秀测试工程师的必备思维39讲\" textvalue=\"优秀测试工程师的必备思维39讲\">优秀测试工程师的必备思维39讲</a></p><p><strong>我的课程：</strong></p><p><a href=\"https://coding.imooc.com/class/398.html?mc_marking=388439060529cc3bf69d2e9960e99385&mc_channel=shouji\" target=\"_blank\" title=\"编程必备基础 大话HTTP协议\" textvalue=\"编程必备基础 大话HTTP协议\">编程必备基础 大话HTTP协议</a></p><p><a href=\"https://coding.imooc.com/class/277.html?mc_marking=4b17dbb2a9c67ea3131cef1e6c865c3b&mc_channel=shouji\" target=\"_blank\" title=\"小白福音 零基础入门软件测试 首选必备课程\" textvalue=\"小白福音 零基础入门软件测试 首选必备课程\">小白福音 零基础入门软件测试 首选必备课程</a></p><p><a href=\"https://coding.imooc.com/class/305.html?mc_marking=7d3933c6bc58bf477416d5e2871d77c2&mc_channel=shouji\" target=\"_blank\" title=\"LoadRunner性能测试实战训练营 收藏\" textvalue=\"LoadRunner性能测试实战训练营\">LoadRunner性能测试实战训练营</a></p><p><a href=\"https://coding.imooc.com/class/238.html?mc_marking=c3a94b7a8f472bf169082c7c0fdad789&mc_channel=shouji\" target=\"_blank\" title=\"Selenium3.0平台级自动化测试框架综合实战\" textvalue=\"Selenium3.0平台级自动化测试框架综合实战\">Selenium3.0平台级自动化测试框架综合实战</a></p>\n\t\t\t\t\t",
                "cover": [
                    "https://img1.sycdn.imooc.com/5dfc48470001d0c605200311.png",
                    "https://img1.sycdn.imooc.com/5dfc488a00011b8b04960312.png",
                    "https://img1.sycdn.imooc.com/5dfc48aa0001e5ee01900224.png",
                    "https://img1.sycdn.imooc.com/5dfc48cc0001bef502660250.png",
                    "https://img1.sycdn.imooc.com/5dfc48e90001113403840338.png",
                    "https://img1.sycdn.imooc.com/5dfc49090001b9ca01700187.png",
                    "https://img1.sycdn.imooc.com/5dfc492b0001701701960267.png",
                    "https://img1.sycdn.imooc.com/5dfc494a0001a03b01760207.png"
                ],
                "mode": "column"
            }
        ]
    },
    "user": { // 用户表
        "data": [{
                "id": "8010388",
                "author_name": "Java架构师讲师团",
                "avatar": "//img2.sycdn.imooc.com/5dafce1a00013fd501400140-160-160.jpg",
                "status": "normal",
                "fans_count": 0,
                "professional": "架构师",
                "explain": "架构师成长沟通群878622640，欢迎加入~",
                "gender": "男",
                "follow_count": 0,
                "integral_count": "",
                "article_likes_ids": [],
                "author_likes_ids": [],
                "thumbs_up_article_ids": [],
                "label_ids": [],
                "loginName": "alan9558",
                "password": "123qwe",
                "phone": "13552752517",
                "article_ids": [
                    "302042",
                    "301911"
                ]
            },
            {
                "id": "4294850",
                "author_name": "7七月",
                "avatar": "//img3.sycdn.imooc.com/54584e2c00010a2c02200220-160-160.jpg",
                "status": "normal",
                "fans_count": 0,
                "professional": "全栈工程师",
                "explain": "十年研发及团队管理经验，对程序员面临的各种问题深有体会；精通Python、Java、Node.js、JavaScript等语言，对Web的基础研发、高并发处理与分布式有非常深入的理解。课程讲解深入浅出，极为擅长培养学生的编程思维。",
                "gender": "男",
                "follow_count": 0,
                "integral_count": "",
                "article_likes_ids": [],
                "author_likes_ids": [],
                "thumbs_up_article_ids": [],
                "label_ids": [],
                "article_ids": [
                    "298045",
                    "286282"
                ]
            },
            {
                "id": "5027812",
                "author_name": "快乐动起来呀",
                "avatar": "//img3.sycdn.imooc.com/54584cb50001e5b302200220-160-160.jpg",
                "status": "normal",
                "fans_count": 0,
                "professional": "Web前端工程师",
                "explain": "7年工作经验的资深前端工程师，主要从事Web视频领域的底层开发。先后在360、去哪儿网、某知名视频公司工作。",
                "gender": "男",
                "follow_count": 0,
                "integral_count": "",
                "article_likes_ids": [],
                "author_likes_ids": [],
                "thumbs_up_article_ids": [],
                "label_ids": [],
                "article_ids": [
                    "294509",
                    "293012"
                ]
            },
            {
                "id": "4427201",
                "author_name": "双越",
                "avatar": "//img4.sycdn.imooc.com/5a9fc8070001a82402060220-160-160.jpg",
                "status": "normal",
                "fans_count": 0,
                "professional": "Web前端工程师",
                "explain": "资深前端工程师，PMP，项目技术负责人，现就职于BAT一线互联网公司。他的博客总流量过百万，如《深入理解JS原型和闭包》《深入理解JS异步》等。在慕课网已推出《前端javascript面试技巧》《nodejs 从零开发博客项目 web server》等教程。",
                "gender": "男",
                "follow_count": 0,
                "integral_count": "",
                "article_likes_ids": [],
                "author_likes_ids": [],
                "thumbs_up_article_ids": [],
                "label_ids": [],
                "article_ids": [
                    "300475",
                    "293310"
                ]
            },
            {
                "id": "108955",
                "author_name": "liuyubobobo",
                "avatar": "//img4.sycdn.imooc.com/5347593e00010cfb01400140-160-160.jpg",
                "status": "normal",
                "fans_count": 0,
                "professional": "全栈工程师",
                "explain": "创业者，全栈工程师，持续学习者。对技术开发，产品设计、前后端，ios，html5，智能算法等领域均有接触；拥有多款独立App作品；对一切可编程的东西有浓厚兴趣，对游戏编程格外感兴趣。相信编程改变一切。",
                "gender": "男",
                "follow_count": 0,
                "integral_count": "",
                "article_likes_ids": [],
                "author_likes_ids": [],
                "thumbs_up_article_ids": [],
                "label_ids": [],
                "article_ids": [
                    "289159",
                    "26624"
                ]
            },
            {
                "id": "2255006",
                "author_name": "bobby",
                "avatar": "//img1.sycdn.imooc.com/58d9c48f0001ad0304070270-160-160.jpg",
                "status": "normal",
                "fans_count": 0,
                "professional": "全栈工程师",
                "explain": "python全栈工程师，五年工作经验，喜欢钻研python技术，对爬虫、web开发以及机器学习有浓厚的兴趣，关注前沿技术以及发展趋势。",
                "gender": "男",
                "follow_count": 0,
                "integral_count": "",
                "article_likes_ids": [],
                "author_likes_ids": [],
                "thumbs_up_article_ids": [],
                "label_ids": [],
                "article_ids": [
                    "291507",
                    "283364"
                ]
            },
            {
                "id": "4873493",
                "author_name": "李超",
                "avatar": "//img1.sycdn.imooc.com/5b9876c60001ffc914821482-160-160.jpg",
                "status": "normal",
                "fans_count": 0,
                "professional": "全栈工程师",
                "explain": "10多年的软件开发经历，8年多的音视频直播行业相关经验，6年多的团队管理经验，丰富的linux开发经验，对Linux内核做过深入分析。参加并设计了多个高负载，大并发服务器架构。",
                "gender": "男",
                "follow_count": 0,
                "integral_count": "",
                "article_likes_ids": [],
                "author_likes_ids": [],
                "thumbs_up_article_ids": [],
                "label_ids": [],
                "article_ids": [
                    "295301",
                    "286567"
                ]
            },
            {
                "id": "6685330",
                "author_name": "大壮老师",
                "avatar": "//img1.sycdn.imooc.com/54584f850001c0bc02200220-160-160.jpg",
                "status": "normal",
                "fans_count": 0,
                "professional": "Python工程师",
                "explain": "目前任职于某大型互联网公司人工智能中心。Python开发工程师，主要负责汽车简历数据抓取、商业推广平台数据抓取及接口开发、竞品信息数据抓取等工作。 开发语言：python、autoit。项目中主要使用工具requests 多线程抓取网页系统数据，使用autoit抓取软件系统数据，使用appium抓取app系统数据等。使用scrapy进行大数据量信息抓取。",
                "gender": "男",
                "follow_count": 0,
                "integral_count": "",
                "article_likes_ids": [],
                "author_likes_ids": [],
                "thumbs_up_article_ids": [],
                "label_ids": [],
                "article_ids": [
                    "292698",
                    "292504"
                ]
            },
            {
                "id": "6433657",
                "author_name": "风落几番",
                "avatar": "//img3.sycdn.imooc.com/5b2a0c4d0001029d09600960-160-160.jpg",
                "status": "normal",
                "fans_count": 0,
                "professional": "全栈工程师",
                "explain": "蚂蚁金服测试专家，带领团队从零建立多个大型项目安全测试，针对Web安全测试搭建了基于开源工具的安全测试架构，独立开发基于WebDriver的自动化测试平台，著有《LoadRunner性能测试巧匠训练营》。",
                "gender": "男",
                "follow_count": 0,
                "integral_count": "",
                "article_likes_ids": [],
                "author_likes_ids": [],
                "thumbs_up_article_ids": [],
                "label_ids": [],
                "article_ids": [
                    "301818",
                    "298932"
                ]
            }
        ]
    },
    "label": { // 分类表
        "data": [{
                "name": "前端开发",
                "user": []
            },
            {
                "name": "后端开发",
                "user": []
            },
            {
                "name": "移动开发",
                "user": []
            },
            {
                "name": "职场生活",
                "user": []
            },
            {
                "name": "精彩直播",
                "user": []
            },
            {
                "name": "每日一题",
                "user": []
            }
        ]
    }
}